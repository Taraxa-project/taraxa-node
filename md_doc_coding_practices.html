<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TARAXA: C++ Best Practices Guidelines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TARAXA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_doc_coding_practices.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">C++ Best Practices Guidelines </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/isocpp/CppCoreGuidelines">Source</a></p>
<h1><a class="anchor" id="autotoc_md56"></a>
The structure of this document</h1>
<p>Each rule (guideline, suggestion) can have several parts:</p>
<ul>
<li>The rule itself &ndash; e.g., <b>no naked <code>new</code></b></li>
<li><b>Reason**s (rationales) &ndash; because programmers find it hard to follow rules they don't understand</b></li>
<li><b>**Example**s &ndash; because rules are hard to understand in the abstract; can be positive or negative</b></li>
<li><b>**Alternative**s &ndash; for "don't do this" rules</b></li>
<li><b>**Exception**s &ndash; we prefer simple general rules. However, many rules apply widely, but not universally, so exceptions must be listed</b></li>
<li><b>**Enforcement</b> &ndash; ideas about how the rule might be checked "mechanically"</li>
<li>**See also**s &ndash; references to related rules and/or further discussion (in this document or elsewhere)</li>
<li>**Note**s (comments) &ndash; something that needs saying that doesn't fit the other classifications</li>
</ul>
<p>Some rules are hard to check mechanically, but they all meet the minimal criteria that an expert programmer can spot many violations without too much trouble. We hope that "mechanical" tools will improve with time to approximate what such an expert programmer notices. Also, we assume that the rules will be refined over time to make them more precise and checkable.</p>
<p>Topics:</p><ul>
<li><a href="#compiletimechecking">1. Compile time checking</a></li>
<li><a href="#avoidnonconst">2. Avoid non-const</a></li>
<li><a href="#ruleofzero">3. Rule of zero</a></li>
<li><a href="#ruleoffive">4. Rule of five</a></li>
<li><a href="#smartptr">5. Raw pointer ownership transfer</a></li>
<li><a href="#usingsmartptr">6. Choosing of smart pointer</a></li>
<li><a href="#singlealloc">7. Explicit resource allocation</a></li>
<li><a href="#passsmartptr">8. Passing smart pointers</a></li>
<li><a href="#varlimitscope">9. Variable scope</a></li>
<li><a href="#varrecycle">10. Variable recycling</a></li>
<li><a href="#macrosconsts">11. Macros constants</a></li>
<li><a href="#magicconstants">12. Magic constants</a></li>
<li><a href="#nullptr">13. nullptr</a></li>
<li><a href="#construct">14. Narrowing</a></li>
<li><a href="#referencecapture">15. Lambda, capture by reference</a></li>
<li><a href="#valuecapture">16. Lambda, capture by value</a></li>
<li><a href="#thiscapture">17. Lambda, capture this</a></li>
<li><a href="#defaultctor">18. Default constructor</a></li>
<li><a href="#explicitctor">19. Explicit constructor</a></li>
<li><a href="#alwaysinitialize">20. Always initialize an object</a></li>
<li><a href="#lambdainit">21. Use lambdas for complex initialization</a></li>
<li><a href="#orderctor">22. Initialize class members</a></li>
<li><a href="#inclassinitializer">23. In-class initializers</a></li>
<li><a href="#initializetoassignment">24. Prefer initialization to assignment</a></li>
<li><a href="#castsnamed">25. Named cast</a></li>
<li><a href="#castsconst">26. Don't cast away <code>const</code></a></li>
<li><a href="#symmetric">27. Symmetric operators</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md57"></a>
&lt;a name="compiletimechecking"&gt;&lt;/a&gt; 1. Prefer compile-time checking to run-time checking</h2>
<h4><a class="anchor" id="autotoc_md58"></a>
Reason</h4>
<p>Code clarity and performance. You don't need to write error handlers for errors caught at compile time.</p>
<h4><a class="anchor" id="autotoc_md59"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="comment">// Int is an alias used for integers</span></div>
<div class="line"><span class="keywordtype">int</span> bits {0};</div>
<div class="line"><span class="keywordflow">for</span> (Int i = 1; i; i &lt;&lt;= 1)</div>
<div class="line">{</div>
<div class="line">  ++bits;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (bits &lt; 32)</div>
<div class="line">{</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Int too small\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This example fails to achieve what it is trying to achieve (because overflow is undefined) and should be replaced with a simple <code>static_assert</code>: </p><div class="fragment"><div class="line"><span class="comment">// Int is an alias used for integers</span></div>
<div class="line">static_assert(<span class="keyword">sizeof</span>(Int) &gt;= 4);    <span class="comment">// do: compile-time check</span></div>
</div><!-- fragment --><p> Or better still just use the type system and replace <code>Int</code> with <code>int32_t</code>.</p>
<p><b>Alternative formulation</b>: Don't postpone to run time what can be done well at compile time.</p>
<h4><a class="anchor" id="autotoc_md60"></a>
Enforcement</h4>
<ul>
<li>Look for pointer arguments.</li>
<li>Look for run-time checks for range violations.</li>
</ul>
<h2><a class="anchor" id="autotoc_md61"></a>
&lt;a name="avoidnonconst"&gt;&lt;/a&gt; 2. Avoid non-&lt;tt&gt;const&lt;/tt&gt; global variables</h2>
<h4><a class="anchor" id="autotoc_md62"></a>
Reason</h4>
<p>Non-<code>const</code> global variables hide dependencies and make the dependencies subject to unpredictable changes.</p>
<h4><a class="anchor" id="autotoc_md63"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Data</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ... lots of stuff ...</span></div>
<div class="line">} data;            <span class="comment">// non-const data</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Compute()     <span class="comment">// don&#39;t, hidden dependency to struct data</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ... use data ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Output()     <span class="comment">// don&#39;t, hidden dependency to struct data</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ... use data ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Who else might modify <code>data</code>?</p>
<h4><a class="anchor" id="autotoc_md64"></a>
Note</h4>
<p>Global constants are useful.</p>
<h4><a class="anchor" id="autotoc_md65"></a>
Note</h4>
<p>The rule against global variables applies to namespace scope variables as well.</p>
<p><b>Alternative</b>: If you use global (more generally namespace scope) data to avoid copying, consider passing the data as an object by reference to <code>const</code>. Another solution is to define the data as the state of some object and the operations as member functions.</p>
<p><b>Warning</b>: Beware of data races: If one thread can access nonlocal data (or data passed by reference) while another thread executes the callee, we can have a data race. Every pointer or reference to mutable data is a potential data race.</p>
<h4><a class="anchor" id="autotoc_md66"></a>
Note</h4>
<p>You cannot have a race condition on immutable data.</p>
<h4><a class="anchor" id="autotoc_md67"></a>
Enforcement</h4>
<p>(Simple) Report all non-<code>const</code> variables declared at namespace scope.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
&lt;a name="ruleofzero"&gt;&lt;/a&gt; 3. If you can avoid defining default operations, do</h2>
<h4><a class="anchor" id="autotoc_md69"></a>
Reason</h4>
<p>It's the simplest and gives the cleanest semantics.</p>
<h4><a class="anchor" id="autotoc_md70"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>NamedMap</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// ... no default operations declared ...</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::string mName;</div>
<div class="line">  std::map&lt;int, int&gt; mRep;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">NamedMap nm;        <span class="comment">// default construct</span></div>
<div class="line">NamedMap nm2 {nm};  <span class="comment">// copy construct</span></div>
</div><!-- fragment --><p> Since <code>std::map</code> and <code>string</code> have all the special functions, no further work is needed.</p>
<h4><a class="anchor" id="autotoc_md71"></a>
Note</h4>
<p>This is known as **"the rule of zero"**.</p>
<h4><a class="anchor" id="autotoc_md72"></a>
Enforcement</h4>
<p>(Not enforceable) While not enforceable, a good static analyzer can detect patterns that indicate a possible improvement to meet this rule. For example, a class with a (pointer, size) pair of member and a destructor that <code>delete</code>s the pointer could probably be converted to a <code>vector</code>.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
&lt;a name="ruleoffive"&gt;&lt;/a&gt; 4. If you define or &lt;tt&gt;=delete&lt;/tt&gt; any default operation, define or &lt;tt&gt;=delete&lt;/tt&gt; them all</h2>
<h4><a class="anchor" id="autotoc_md74"></a>
Reason</h4>
<p>The semantics of the special functions are closely related, so if one needs to be non-default, the odds are that others need modification too.</p>
<h4><a class="anchor" id="autotoc_md75"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>M2</div>
<div class="line">{   <span class="comment">// bad: incomplete set of default operations</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  <span class="comment">// ... no copy or move operations ...</span></div>
<div class="line">  ~M2() { <span class="keyword">delete</span>[] mRep; }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::pair&lt;int, int&gt;* mRep;  <span class="comment">// zero-terminated set of pairs</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Use()</div>
<div class="line">{</div>
<div class="line">  M2 x;</div>
<div class="line">  M2 y;</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  x = y;   <span class="comment">// the default assignment</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Given that "special attention" was needed for the destructor (here, to deallocate), the likelihood that copy and move assignment (both will implicitly destroy an object) are correct is low (here, we would get double deletion).</p>
<h4><a class="anchor" id="autotoc_md76"></a>
Example, good</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>M2</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  M2(<span class="keyword">const</span> std::size_t size);</div>
<div class="line">  M2(<span class="keyword">const</span> M2&amp;) = <span class="keyword">delete</span>; <span class="comment">// or allocate and copy</span></div>
<div class="line">  M2&amp; operator=(<span class="keyword">const</span> M2&amp;) = <span class="keyword">delete</span>; <span class="comment">// or allocate and copy</span></div>
<div class="line">  M2(M2&amp;&amp; rhs) = <span class="keyword">delete</span>;  <span class="comment">// or move and clear source pointer</span></div>
<div class="line">  M2&amp; operator=(M2&amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">// or move and clear source pointer</span></div>
<div class="line">  </div>
<div class="line">  ~M2() { <span class="keyword">delete</span>[] mRep; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::pair&lt;int, int&gt;* mRep;  <span class="comment">// zero-terminated set of pairs</span></div>
<div class="line">};</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md77"></a>
Note</h4>
<p>This is known as **"the rule of five"** or **"the rule of six"**, depending on whether you count the default constructor.</p>
<h4><a class="anchor" id="autotoc_md78"></a>
Note</h4>
<p>If you want a default implementation of a default operation (while defining another), write <code>=default</code> to show you're doing so intentionally for that function. If you don't want a default operation, suppress it with <code>=delete</code>.</p>
<h4><a class="anchor" id="autotoc_md79"></a>
Note</h4>
<p>Compilers enforce much of this rule and ideally warn about any violation.</p>
<h4><a class="anchor" id="autotoc_md80"></a>
Note</h4>
<p>Relying on an implicitly generated copy operation in a class with a destructor is deprecated.</p>
<h4><a class="anchor" id="autotoc_md81"></a>
Enforcement</h4>
<p>(Simple) A class should have a declaration (even a <code>=delete</code> one) for either all or none of the special functions.</p>
<h2><a class="anchor" id="autotoc_md82"></a>
&lt;a name="smartptr"&gt;&lt;/a&gt; 5. Never transfer ownership by a raw pointer (&lt;tt&gt;T*&lt;/tt&gt;) or reference (&lt;tt&gt;T&amp;&lt;/tt&gt;)</h2>
<h4><a class="anchor" id="autotoc_md83"></a>
Reason</h4>
<p>If there is any doubt whether the caller or the callee owns an object, leaks or premature destruction will occur.</p>
<h4><a class="anchor" id="autotoc_md84"></a>
Example</h4>
<p>Consider: </p><div class="fragment"><div class="line">X* Compute(args)    <span class="comment">// don&#39;t, nobody knows whether pointer should be released</span></div>
<div class="line">{</div>
<div class="line">  X* res = <span class="keyword">new</span> X{};</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Who deletes the returned <code>X</code>? The problem would be harder to spot if compute returned a reference. Consider returning the result by value (use move semantics if the result is large): </p><div class="fragment"><div class="line">vector&lt;double&gt; Compute(args)  <span class="comment">// good</span></div>
<div class="line">{</div>
<div class="line">  vector&lt;double&gt; res(10000);</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <b>Alternative</b>: Using a "smart pointer", such as <code>unique_ptr</code> (for exclusive ownership) and <code>shared_ptr</code> (for shared ownership). However, that is less elegant and often less efficient than returning the object itself, so use smart pointers only if reference semantics are needed.</p>
<p><b>Alternative</b>: Sometimes older code can't be modified because of ABI compatibility requirements or lack of resources. In that case, mark owning pointers using <code>owner</code> from the <a href="#S-gsl">guideline support library</a>: </p><div class="fragment"><div class="line">gsl::owner&lt;X*&gt; Compute(args)    <span class="comment">// It is now clear that ownership is transferred</span></div>
<div class="line">{</div>
<div class="line">  gsl::owner&lt;X*&gt; res = <span class="keyword">new</span> X{};</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This tells analysis tools that <code>res</code> is an owner. That is, its value must be <code>delete</code>d or transferred to another owner, as is done here by the <code>return</code>.</p>
<p><code>owner</code> is used similarly in the implementation of resource handles.</p>
<h4><a class="anchor" id="autotoc_md85"></a>
Note</h4>
<p>Every object passed as a raw pointer (or iterator) is assumed to be owned by the caller, so that its lifetime is handled by the caller. Viewed another way: ownership transferring APIs are relatively rare compared to pointer-passing APIs, so the default is "no ownership transfer."</p>
<p><b>See also</b>: <a href="#usingsmartptr">Using smart pointers</a>, <a href="#passsmartptr">Use of smart pointer arguments</a>.</p>
<h4><a class="anchor" id="autotoc_md86"></a>
Enforcement</h4>
<ul>
<li>(Simple) Warn on <code>delete</code> of a raw pointer that is not an <code>owner&lt;T&gt;</code>. Suggest use of standard-library resource handle or use of <code>owner&lt;T&gt;</code>.</li>
<li>(Simple) Warn on failure to either <code>reset</code> or explicitly <code>delete</code> an <code>owner</code> pointer on every code path.</li>
<li>(Simple) Warn if the return value of <code>new</code> or a function call with an <code>owner</code> return value is assigned to a raw pointer or non-<code>owner</code> reference.</li>
</ul>
<h2><a class="anchor" id="autotoc_md87"></a>
&lt;a name="usingsmartptr"&gt;&lt;/a&gt; 6. Choose appropriate smart pointer or why we have more smart pointers?</h2>
<h4><a class="anchor" id="autotoc_md88"></a>
Reason</h4>
<p>Use appropriate smart pointer and avoid the waste of resources.</p>
<h4><a class="anchor" id="autotoc_md89"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Foo()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> ptr = std::make_shared&lt;MyBigClass&gt;();</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  Use(*ptr); <span class="comment">// may throw exception</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Shared pointer allocate reference counting even ownership is never transported or copied.</p>
<p><b>Alternative</b>: If ownership owns only one object in a time, then use **<code>std::unique_ptr</code>** even that ownership can or will be moved to other object. Using std::unique_ptr is the simplest way to avoid leaks. It is reliable, it makes the type system do much of the work to validate ownership safety, it increases readability, and it has zero or near zero run-time cost.</p>
<p><b>Alternative</b>: If ownership can be duplicated to other object then use **<code>std::shared_ptr</code>**.</p>
<p><b>Note</b>: In both cases prefer creation via <code>std::make_unique</code> or <code>std::make_shared</code>. If you first make an object and then give it to a shared_ptr constructor, you (most likely) do one more allocation (and later deallocation) than if you use <code>std::make_shared</code> because the reference counts must be allocated separately from the object. Use <code>make_unique</code> just for convenience and consistency with <code>std::shared_ptr</code>. <code>std::unique_ptr</code> shall be the default pointer type, <code>std::shared_ptr</code> shall be used only if needed.</p>
<h4><a class="anchor" id="autotoc_md90"></a>
See also</h4>
<p><a href="#singlealloc">Explicit resource allocation</a></p>
<p><a href="http://www.modernescpp.com/index.php/c-core-guidelines-rules-to-smart-pointers">C++ Core Guidelines: Rules for Smart Pointers</a></p>
<h2><a class="anchor" id="autotoc_md91"></a>
&lt;a name="singlealloc"&gt;&lt;/a&gt; 7. Perform at most one explicit resource allocation in a single expression statement</h2>
<h4><a class="anchor" id="autotoc_md92"></a>
Reason</h4>
<p>If you perform two explicit resource allocations in one statement, you could leak resources because the order of evaluation of many subexpressions, including function arguments, is unspecified.</p>
<h4><a class="anchor" id="autotoc_md93"></a>
Example</h4>
<p>void fun(shared_ptr&lt;Widget&gt; sp1, shared_ptr&lt;Widget&gt; sp2);</p>
<p>This <code>fun</code> can be called like this: </p><div class="fragment"><div class="line"><span class="comment">// BAD: potential leak</span></div>
<div class="line">fun(shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget(a, b)), shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget(c, d)));</div>
</div><!-- fragment --><p> This is exception-unsafe because the compiler may reorder the two expressions building the function's two arguments. In particular, the compiler can interleave execution of the two expressions: Memory allocation (by calling <code>operator new</code>) could be done first for both objects, followed by attempts to call the two <code>Widget</code> constructors. If one of the constructor calls throws an exception, then the other object's memory will never be released!</p>
<p>This subtle problem has a simple solution: Never perform more than one explicit resource allocation in a single expression statement. For example: </p><div class="fragment"><div class="line">shared_ptr&lt;Widget&gt; sp1(<span class="keyword">new</span> Widget(a, b)); <span class="comment">// Better, but messy</span></div>
<div class="line">fun(sp1, <span class="keyword">new</span> Widget(c, d));</div>
</div><!-- fragment --><p> The best solution is to avoid explicit allocation entirely use factory functions that return owning objects: </p><div class="fragment"><div class="line">fun(make_shared&lt;Widget&gt;(a, b), make_shared&lt;Widget&gt;(c, d)); <span class="comment">// Best</span></div>
</div><!-- fragment --><p> Write your own factory wrapper if there is not one already.</p>
<h4><a class="anchor" id="autotoc_md94"></a>
Enforcement</h4>
<ul>
<li>Flag expressions with multiple explicit resource allocations (problem: how many direct resource allocations can we recognize?)</li>
</ul>
<h2><a class="anchor" id="autotoc_md95"></a>
&lt;a name="passsmartptr"&gt;&lt;/a&gt; 8. Take smart pointers as parameters only to explicitly express lifetime semantics</h2>
<h4><a class="anchor" id="autotoc_md96"></a>
Reason</h4>
<p>Accepting a smart pointer to a <code>widget</code> is wrong if the function just needs the <code>widget</code> itself. It should be able to accept any <code>widget</code> object, not just ones whose lifetimes are managed by a particular kind of smart pointer. A function that does not manipulate lifetime should take raw pointers or references instead.</p>
<h4><a class="anchor" id="autotoc_md97"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="comment">// callee</span></div>
<div class="line"><span class="keywordtype">void</span> Foo(std::shared_ptr&lt;Widget&gt;&amp; w)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  Use(*w); <span class="comment">// only use of w -- the lifetime is not used at all</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// caller</span></div>
<div class="line">std::shared_ptr&lt;Widget&gt; myWidget = <span class="comment">/* ... */</span>;</div>
<div class="line">Foo(myWidget);</div>
<div class="line"> </div>
<div class="line">Widget stackWidget;</div>
<div class="line">Foo(stackWidget); <span class="comment">// error</span></div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md98"></a>
Example, good</h4>
<div class="fragment"><div class="line"><span class="comment">// callee</span></div>
<div class="line"><span class="keywordtype">void</span> Foo(Widget&amp; w)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  Use(w);</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// caller</span></div>
<div class="line">std::shared_ptr&lt;Widget&gt; myWidget = <span class="comment">/* ... */</span>;</div>
<div class="line">Foo(*myWidget);</div>
<div class="line"> </div>
<div class="line">Widget stackWidget;</div>
<div class="line">Foo(stackWidget); <span class="comment">// ok -- now this works</span></div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md99"></a>
Enforcement</h4>
<ul>
<li>(Simple) Warn if a function takes a parameter of a smart pointer type (that overloads <code>operator-&gt;</code> or <code>operator*</code>) that is copyable but the function only calls any of: <code>operator*</code>, <code>operator-&gt;</code> or <code>get()</code>. Suggest using a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>Flag a parameter of a smart pointer type (a type that overloads <code>operator-&gt;</code> or <code>operator*</code>) that is copyable/movable but never copied/moved from in the function body, and that is never modified, and that is not passed along to another function that could do so. That means the ownership semantics are not used. Suggest using a <code>T*</code> or <code>T&amp;</code> instead.</li>
</ul>
<h2><a class="anchor" id="autotoc_md100"></a>
&lt;a name="varlimitscope"&gt;&lt;/a&gt; 9. Declare names in for-statement initializers and conditions to limit scope</h2>
<h4><a class="anchor" id="autotoc_md101"></a>
Reason</h4>
<p>Readability. Minimize resource retention.</p>
<h4><a class="anchor" id="autotoc_md102"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> use()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">string</span> s; cin &gt;&gt; s;)</div>
<div class="line">  {</div>
<div class="line">    v.push_back(s);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 20; ++i)</div>
<div class="line">  {   <span class="comment">// good: i is local to for-loop</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span> pc = <span class="keyword">dynamic_cast&lt;</span>Circle*<span class="keyword">&gt;</span>(ps))</div>
<div class="line">  {   <span class="comment">// good: pc is local to if-statement</span></div>
<div class="line">    <span class="comment">// ... deal with Circle ...</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// ... handle error ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md103"></a>
Enforcement</h4>
<ul>
<li>Flag loop variables declared before the loop and not used after the loop</li>
<li>(hard) Flag loop variables declared before the loop and used after the loop for an unrelated purpose.</li>
</ul>
<h4><a class="anchor" id="autotoc_md104"></a>
C++17 example</h4>
<p>Note: C++17 also adds <code>if</code> and <code>switch</code> initializer statements. These require C++17 support. </p><div class="fragment"><div class="line">map&lt;int, string&gt; mymap;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> result = mymap.insert(value); result.second)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// insert succeeded, and result is valid for this block</span></div>
<div class="line">  Use(result.first);  <span class="comment">// ok</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} <span class="comment">// result is destroyed here</span></div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md105"></a>
C++17 enforcement (if using a C++17 compiler)</h4>
<ul>
<li>Flag selection/loop variables declared before the body and not used after the body</li>
<li>(hard) Flag selection/loop variables declared before the body and used after the body for an unrelated purpose.</li>
</ul>
<h2><a class="anchor" id="autotoc_md106"></a>
&lt;a name="varrecycle"&gt;&lt;/a&gt; 10. Don't use a variable for two unrelated purposes</h2>
<h4><a class="anchor" id="autotoc_md107"></a>
Reason</h4>
<p>Readability and safety.</p>
<h4><a class="anchor" id="autotoc_md108"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Use()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; 20; ++i) { <span class="comment">/* ... */</span> }</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; 200; ++i) { <span class="comment">/* ... */</span> } <span class="comment">// bad: i recycled</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md109"></a>
Note</h4>
<p>As an optimization, you may want to reuse a buffer as a scratch pad, but even then prefer to limit the variable's scope as much as possible and be careful not to cause bugs from data left in a recycled buffer as this is a common source of security bugs. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Write() {</div>
<div class="line">  std::string buffer;             <span class="comment">// to avoid reallocations on every loop iteration</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; o : objects)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// First part of the work.</span></div>
<div class="line">    generate_first_String(buffer, o);</div>
<div class="line">    Write(buffer);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Second part of the work.</span></div>
<div class="line">    generate_second_string(buffer, o);</div>
<div class="line">    Write(buffer);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// etc...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md110"></a>
Enforcement</h4>
<p>Flag recycled variables.</p>
<h2><a class="anchor" id="autotoc_md111"></a>
&lt;a name="macrosconsts"&gt;&lt;/a&gt; 11. Don't use macros for constants or "functions"</h2>
<h4><a class="anchor" id="autotoc_md112"></a>
Reason</h4>
<p>Macros are a major source of bugs. Macros don't obey the usual scope and type rules. Macros don't obey the usual rules for argument passing. Macros ensure that the human reader sees something different from what the compiler sees. Macros complicate tool building.</p>
<h4><a class="anchor" id="autotoc_md113"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#define PI 3.14</span></div>
<div class="line"><span class="preprocessor">#define SQUARE(a, b) (a * b)</span></div>
</div><!-- fragment --><p> Even if we hadn't left a well-known bug in <code>SQUARE</code> there are much better behaved alternatives; for example: </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">double</span> pi = 3.14;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T square(T a, T b) { <span class="keywordflow">return</span> a * b; }</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md114"></a>
Enforcement</h4>
<p>Scream when you see a macro that isn't just used for source control (e.g., <code>#ifdef</code>)</p>
<h2><a class="anchor" id="autotoc_md115"></a>
&lt;a name="magicconstants"&gt;&lt;/a&gt; 12. Avoid "magic constants"; use symbolic constants</h2>
<h4><a class="anchor" id="autotoc_md116"></a>
Reason</h4>
<p>Unnamed constants embedded in expressions are easily overlooked and often hard to understand:</p>
<h4><a class="anchor" id="autotoc_md117"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> m = 1; m &lt;= 12; ++m)   <span class="comment">// don&#39;t: magic constant 12</span></div>
<div class="line">  cout &lt;&lt; month[m] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --><p> No, we don't all know that there are 12 months, numbered 1..12, in a year. Better: </p><div class="fragment"><div class="line"><span class="comment">// months are indexed 1..12</span></div>
<div class="line">constexpr <span class="keywordtype">int</span> first_month = 1;</div>
<div class="line">constexpr <span class="keywordtype">int</span> last_month = 12;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> m = first_month; m &lt;= last_month; ++m)   <span class="comment">// better</span></div>
<div class="line">  cout &lt;&lt; month[m] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --><p> Better still, don't expose constants: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> m : month)</div>
<div class="line">  cout &lt;&lt; m &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md118"></a>
Enforcement</h4>
<p>Flag literals in code. Give a pass to <code>0</code>, <code>1</code>, <code>nullptr</code>, <code>\n</code>, <code>""</code>, and others on a positive list.</p>
<h2><a class="anchor" id="autotoc_md119"></a>
&lt;a name="nullptr"&gt;&lt;/a&gt; 13. Use &lt;tt&gt;nullptr&lt;/tt&gt; rather than &lt;tt&gt;0&lt;/tt&gt; or &lt;tt&gt;NULL&lt;/tt&gt;</h2>
<h4><a class="anchor" id="autotoc_md120"></a>
Reason</h4>
<p>Readability. Minimize surprises: <code>nullptr</code> cannot be confused with an <code>int</code>. <code>nullptr</code> also has a well-specified (very restrictive) type, and thus works in more scenarios where type deduction might do the wrong thing on <code>NULL</code> or <code>0</code>.</p>
<h4><a class="anchor" id="autotoc_md121"></a>
Example</h4>
<p>Consider: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">char</span>*);</div>
<div class="line">f(0);         <span class="comment">// call f(int)</span></div>
<div class="line">f(<span class="keyword">nullptr</span>);   <span class="comment">// call f(char*)</span></div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md122"></a>
Enforcement</h4>
<p>Flag uses of <code>0</code> and <code>NULL</code> for pointers. The transformation may be helped by simple program transformation.</p>
<h2><a class="anchor" id="autotoc_md123"></a>
&lt;a name="construct"&gt;&lt;/a&gt; 14. Use the &lt;tt&gt;T{e}&lt;/tt&gt;notation for construction</h2>
<h4><a class="anchor" id="autotoc_md124"></a>
Reason</h4>
<p>The <code>T{e}</code> construction syntax makes it explicit that construction is desired. The <code>T{e}</code> construction syntax doesn't allow narrowing. <code>T{e}</code> is the only safe and general expression for constructing a value of type <code>T</code> from an expression <code>e</code>. The casts notations <code>T(e)</code> and <code>(T)e</code> are neither safe nor general.</p>
<h4><a class="anchor" id="autotoc_md125"></a>
Example</h4>
<p>For built-in types, the construction notation protects against narrowing and reinterpretation </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> use(<span class="keywordtype">char</span> ch, <span class="keywordtype">int</span> i, <span class="keywordtype">double</span> d, <span class="keywordtype">char</span>* p, <span class="keywordtype">long</span> <span class="keywordtype">long</span> lng)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> x1 = <span class="keywordtype">int</span>{ch};     <span class="comment">// OK, but redundant</span></div>
<div class="line">  <span class="keywordtype">int</span> x2 = <span class="keywordtype">int</span>{d};      <span class="comment">// error: double-&gt;int narrowing; use a cast if you need to</span></div>
<div class="line">  <span class="keywordtype">int</span> x3 = <span class="keywordtype">int</span>{p};      <span class="comment">// error: pointer to-&gt;int; use a reinterpret_cast if you really need to</span></div>
<div class="line">  <span class="keywordtype">int</span> x4 = <span class="keywordtype">int</span>{lng};    <span class="comment">// error: long long-&gt;int narrowing; use a cast if you need to</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> y1 = int(ch);     <span class="comment">// OK, but redundant</span></div>
<div class="line">  <span class="keywordtype">int</span> y2 = int(d);      <span class="comment">// bad: double-&gt;int narrowing; use a cast if you need to</span></div>
<div class="line">  <span class="keywordtype">int</span> y3 = int(p);      <span class="comment">// bad: pointer to-&gt;int; use a reinterpret_cast if you really need to</span></div>
<div class="line">  <span class="keywordtype">int</span> y4 = int(lng);    <span class="comment">// bad: long-&gt;int narrowing; use a cast if you need to</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> z1 = (int)ch;     <span class="comment">// OK, but redundant</span></div>
<div class="line">  <span class="keywordtype">int</span> z2 = (int)d;      <span class="comment">// bad: double-&gt;int narrowing; use a cast if you need to</span></div>
<div class="line">  <span class="keywordtype">int</span> z3 = (int)p;      <span class="comment">// bad: pointer to-&gt;int; use a reinterpret_cast if you really need to</span></div>
<div class="line">  <span class="keywordtype">int</span> z4 = (int)lng;    <span class="comment">// bad: long long-&gt;int narrowing; use a cast if you need to</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> The integer to/from pointer conversions are implementation defined when using the <code>T(e)</code> or <code>(T)e</code> notations, and non-portable between platforms with different integer and pointer sizes.</p>
<h4><a class="anchor" id="autotoc_md126"></a>
Note</h4>
<p>When unambiguous, the <code>T</code> can be left out of <code>T{e}</code>. </p><div class="fragment"><div class="line">complex&lt;double&gt; f(complex&lt;double&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> z = f({2*pi, 1});</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md127"></a>
Exception</h4>
<p><code>std::vector</code> and other containers were defined before we had <code>{}</code> as a notation for construction. Consider: </p><div class="fragment"><div class="line">vector&lt;string&gt; vs {10};                           <span class="comment">// ten empty strings</span></div>
<div class="line">vector&lt;int&gt; vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  <span class="comment">// ten elements 1..10</span></div>
<div class="line">vector&lt;int&gt; vi2 {10};                             <span class="comment">// one element with the value 10</span></div>
</div><!-- fragment --><p> How do we get a <code>vector</code> of 10 default initialized <code>int</code>s?</p>
<p>vector&lt;int&gt; v3(10); // ten elements with value 0</p>
<p>The use of <code>()</code> rather than <code>{}</code> for number of elements is conventional (going back to the early 1980s), hard to change, but still a design error: for a container where the element type can be confused with the number of elements, we have an ambiguity that must be resolved. The conventional resolution is to interpret <code>{10}</code> as a list of one element and use <code>(10)</code> to distinguish a size.</p>
<p>This mistake need not be repeated in new code. We can define a type to represent the number of elements: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Count { <span class="keywordtype">int</span> n; };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>Vector</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Vector(Count n);                     <span class="comment">// n default-initialized elements</span></div>
<div class="line">  Vector(initializer_list&lt;T&gt; init);    <span class="comment">// init.size() elements</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Vector&lt;int&gt; v1{10};</div>
<div class="line">Vector&lt;int&gt; v2{Count{10}};</div>
<div class="line">Vector&lt;Count&gt; v3{Count{10}};    <span class="comment">// yes, there is still a very minor problem</span></div>
</div><!-- fragment --><p> The main problem left is to find a suitable name for <code>Count</code>.</p>
<h4><a class="anchor" id="autotoc_md128"></a>
Enforcement</h4>
<p>Flag the C-style <code>(T)e</code> and functional-style <code>T(e)</code> casts.</p>
<h2><a class="anchor" id="autotoc_md129"></a>
&lt;a name="referencecapture"&gt;&lt;/a&gt; 15. Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms</h2>
<h4><a class="anchor" id="autotoc_md130"></a>
Reason</h4>
<p>For efficiency and correctness, you nearly always want to capture by reference when using the lambda locally. This includes when writing or calling parallel algorithms that are local because they join before returning.</p>
<h4><a class="anchor" id="autotoc_md131"></a>
Discussion</h4>
<p>The efficiency consideration is that most types are cheaper to pass by reference than by value.</p>
<p>The correctness consideration is that many calls want to perform side effects on the original object at the call site (see example below). Passing by value prevents this.</p>
<h4><a class="anchor" id="autotoc_md132"></a>
Note</h4>
<p>Unfortunately, there is no simple way to capture by reference to <code>const</code> to get the efficiency for a local call but also prevent side effects.</p>
<h4><a class="anchor" id="autotoc_md133"></a>
Example</h4>
<p>Here, a large object (a network message) is passed to an iterative algorithm, and is it not efficient or correct to copy the message (which may not be copyable): </p><div class="fragment"><div class="line">std::for_each(begin(sockets), end(sockets), [&amp;message](<span class="keyword">auto</span>&amp; socket)</div>
<div class="line">{</div>
<div class="line">  socket.send(message);</div>
<div class="line">});</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md134"></a>
Example</h4>
<p>This is a simple three-stage parallel pipeline. Each <code>stage</code> object encapsulates a worker thread and a queue, has a <code>process</code> function to enqueue work, and in its destructor automatically blocks waiting for the queue to empty before ending the thread. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> send_packets(buffers&amp; bufs)</div>
<div class="line">{</div>
<div class="line">  stage encryptor([] (buffer&amp; b){ <a class="code" href="namespacedev.html#a7f377e436eaf0967cedb0fa1370d17ba">encrypt</a>(b); });</div>
<div class="line">  stage compressor([&amp;](buffer&amp; b){ compress(b); encryptor.process(b); });</div>
<div class="line">  stage decorator([&amp;](buffer&amp; b){ decorate(b); compressor.process(b); });</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; b : bufs) { decorator.process(b); }</div>
<div class="line">}  <span class="comment">// automatically blocks waiting for pipeline to finish</span></div>
<div class="ttc" id="anamespacedev_html_a7f377e436eaf0967cedb0fa1370d17ba"><div class="ttname"><a href="namespacedev.html#a7f377e436eaf0967cedb0fa1370d17ba">dev::encrypt</a></div><div class="ttdeci">void encrypt(Public const &amp;_k, bytesConstRef _plain, bytes &amp;o_cipher)</div><div class="ttdoc">Encrypts plain text using Public key.</div><div class="ttdef"><b>Definition:</b> Common.cpp:95</div></div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md135"></a>
Enforcement</h4>
<p>Flag a lambda that captures by reference, but is used other than locally within the function scope or passed to a function by reference. (Note: This rule is an approximation, but does flag passing by pointer as those are more likely to be stored by the callee, writing to a heap location accessed via a parameter, returning the lambda, etc. The Lifetime rules will also provide general rules that flag escaping pointers and references including via lambdas.)</p>
<h2><a class="anchor" id="autotoc_md136"></a>
&lt;a name="valuecapture"&gt;&lt;/a&gt; 16. Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread</h2>
<h4><a class="anchor" id="autotoc_md137"></a>
Reason</h4>
<p>Pointers and references to locals shouldn't outlive their scope. Lambdas that capture by reference are just another place to store a reference to a local object, and shouldn't do so if they (or a copy) outlive the scope.</p>
<h4><a class="anchor" id="autotoc_md138"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> local{42};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Want a reference to local.</span></div>
<div class="line"><span class="comment">// Note, that after program exits this scope,</span></div>
<div class="line"><span class="comment">// local no longer exists, therefore</span></div>
<div class="line"><span class="comment">// process() call will have undefined behavior!</span></div>
<div class="line">thread_pool.queue_work([&amp;]{ process(local); });</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md139"></a>
Example, good</h4>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> local{42};</div>
<div class="line"><span class="comment">// Want a copy of local.</span></div>
<div class="line"><span class="comment">// Since a copy of local is made, it will</span></div>
<div class="line"><span class="comment">// always be available for the call.</span></div>
<div class="line">thread_pool.queue_work([=]{ process(local); });</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md140"></a>
Enforcement</h4>
<ul>
<li>(Simple) Warn when capture-list contains a reference to a locally declared variable</li>
<li>(Complex) Flag when capture-list contains a reference to a locally declared variable and the lambda is passed to a non-<code>const</code> and non-local context</li>
</ul>
<h2><a class="anchor" id="autotoc_md141"></a>
&lt;a name="thiscapture"&gt;&lt;/a&gt; 17. If you capture &lt;tt&gt;this&lt;/tt&gt;, capture all variables explicitly (no default capture)</h2>
<h4><a class="anchor" id="autotoc_md142"></a>
Reason</h4>
<p>It's confusing. Writing <code>[=]</code> in a member function appears to capture by value, but actually captures data members by reference because it actually captures the invisible <code>this</code> pointer by value. If you meant to do that, write <code>this</code> explicitly.</p>
<h4><a class="anchor" id="autotoc_md143"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> x = 0;</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> f()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> i = 0;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> lambda = [=]{ use(i, x); };   <span class="comment">// BAD: &quot;looks like&quot; copy/value capture</span></div>
<div class="line">    <span class="comment">// [&amp;] has identical semantics and copies the this pointer under the current rules</span></div>
<div class="line">    <span class="comment">// [=,this] and [&amp;,this] are not much better, and confusing</span></div>
<div class="line"> </div>
<div class="line">    x = 42;</div>
<div class="line">    lambda(); <span class="comment">// calls use(0, 42);</span></div>
<div class="line">    x = 43;</div>
<div class="line">    lambda(); <span class="comment">// calls use(0, 43);</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> lambda2 = [i, <span class="keyword">this</span>]{ use(i, x); }; <span class="comment">// ok, most explicit and least confusing</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md144"></a>
Note</h4>
<p>This is under active discussion in standardization, and may be addressed in a future version of the standard by adding a new capture mode or possibly adjusting the meaning of <code>[=]</code>. For now, just be explicit.</p>
<h4><a class="anchor" id="autotoc_md145"></a>
Enforcement</h4>
<ul>
<li>Flag any lambda capture-list that specifies a default capture and also captures <code>this</code> (whether explicitly or via default capture)</li>
</ul>
<h2><a class="anchor" id="autotoc_md146"></a>
&lt;a name="defaultctor"&gt;&lt;/a&gt; 18. Don't define a default constructor that only initializes data members; use in-class member initializers instead</h2>
<h4><a class="anchor" id="autotoc_md147"></a>
Reason</h4>
<p>Using in-class member initializers lets the compiler generate the function for you. The compiler-generated function can be more efficient.</p>
<h4><a class="anchor" id="autotoc_md148"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="keyword">struct </span>X1  <span class="comment">// BAD: doesn&#39;t use member initializers</span></div>
<div class="line">{</div>
<div class="line">  X1() : s{<span class="stringliteral">&quot;default&quot;</span>}, i{1}</div>
<div class="line">  { }</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">string</span> s;</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">};</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md149"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>X2</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// use compiler-generated default constructor</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">string</span> s{<span class="stringliteral">&quot;default&quot;</span>};</div>
<div class="line">  <span class="keywordtype">int</span> i{1};</div>
<div class="line">};</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md150"></a>
Enforcement</h4>
<p>(Simple) A default constructor should do more than just initialize member variables with constants.</p>
<h2><a class="anchor" id="autotoc_md151"></a>
&lt;a name="explicitctor"&gt;&lt;/a&gt; 19. By default, declare single-argument constructors explicit</h2>
<h4><a class="anchor" id="autotoc_md152"></a>
Reason</h4>
<p>To avoid unintended conversions.</p>
<h4><a class="anchor" id="autotoc_md153"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>String</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  String(<span class="keywordtype">int</span>);   <span class="comment">// BAD</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">String s = 10;   <span class="comment">// surprise: string of size 10</span></div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md154"></a>
Exception</h4>
<p>If you really want an implicit conversion from the constructor argument type to the class type, don't use <code>explicit</code>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Complex</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Complex(<span class="keywordtype">double</span> d);   <span class="comment">// OK: we want a conversion from d to {d, 0}</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Complex z = 10.7;   <span class="comment">// unsurprising conversion</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md155"></a>
Enforcement</h4>
<p>(Simple) Single-argument constructors should be declared <code>explicit</code>. Good single argument non-<code>explicit</code> constructors are rare in most code based. Warn for all that are not on a "positive list".</p>
<h2><a class="anchor" id="autotoc_md156"></a>
&lt;a name="alwaysinitialize"&gt;&lt;/a&gt; 20. Always initialize an object</h2>
<h4><a class="anchor" id="autotoc_md157"></a>
Reason</h4>
<p>Avoid used-before-set errors and their associated undefined behavior. Avoid problems with comprehension of complex initialization. Simplify refactoring.</p>
<h4><a class="anchor" id="autotoc_md158"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Use(<span class="keywordtype">int</span> arg)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> i;   <span class="comment">// bad: uninitialized variable</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  i = 7;   <span class="comment">// initialize i</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> No, <code>i = 7</code> does not initialize <code>i</code>; it assigns to it. Also, <code>i</code> can be read in the <code>...</code> part. Better: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Use(<span class="keywordtype">int</span> arg)   <span class="comment">// OK</span></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> i = 7;   <span class="comment">// OK: initialized</span></div>
<div class="line">  <span class="keywordtype">string</span> s;    <span class="comment">// OK: default initialized</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md159"></a>
Note</h4>
<p>The <em>always initialize</em> rule is deliberately stronger than the <em>an object must be set before used</em> language rule. The latter, more relaxed rule, catches the technical bugs, but:</p>
<ul>
<li>It leads to less readable code</li>
<li>It encourages people to declare names in greater than necessary scopes</li>
<li>It leads to harder to read code</li>
<li>It leads to logic bugs by encouraging complex code</li>
<li>It hampers refactoring</li>
</ul>
<p>The <em>always initialize</em> rule is a style rule aimed to improve maintainability as well as a rule protecting against used-before-set errors.</p>
<h4><a class="anchor" id="autotoc_md160"></a>
Example</h4>
<p>Here is an example that is often considered to demonstrate the need for a more relaxed rule for initialization </p><div class="fragment"><div class="line">Widget i;    <span class="comment">// &quot;widget&quot; a type that&#39;s expensive to initialize, possibly a large POD</span></div>
<div class="line">Widget j;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (cond)</div>
<div class="line">{  <span class="comment">// bad: i and j are initialized &quot;late&quot;</span></div>
<div class="line">  i = f1();</div>
<div class="line">  j = f2();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  i = f3();</div>
<div class="line">  j = f4();</div>
<div class="line">}</div>
</div><!-- fragment --><p> This cannot trivially be rewritten to initialize <code>i</code> and <code>j</code> with initializers. Note that for types with a default constructor, attempting to postpone initialization simply leads to a default initialization followed by an assignment. A popular reason for such examples is "efficiency", but a compiler that can detect whether we made a used-before-set error can also eliminate any redundant double initialization.</p>
<p>At the cost of repeating <code>cond</code> we could write: </p><div class="fragment"><div class="line">Widget i = (cond) ? f1() : f3();</div>
<div class="line">Widget j = (cond) ? f2() : f4();</div>
</div><!-- fragment --><p> Assuming that there is a logical connection between <code>i</code> and <code>j</code>, that connection should probably be expressed in code: </p><div class="fragment"><div class="line">std::pair&lt;Widget, Widget&gt; MakeRelatedWidgets(<span class="keywordtype">bool</span> x)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (x) ? {f1(), f2()} : {f3(), f4() };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> init = MakeRelatedWidgets(cond);</div>
<div class="line">Widget i = init.first;</div>
<div class="line">Widget j = init.second;</div>
</div><!-- fragment --><p> Obviously, what we really would like is a construct that initialized n variables from a <code>tuple</code>. For example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> [i, j] = MakeRelatedWidgets(cond);    <span class="comment">// C++17, not C++14</span></div>
</div><!-- fragment --><p> Today, we might approximate that using <code>tie()</code>: </p><div class="fragment"><div class="line">Widget i;       <span class="comment">// bad: uninitialized variable</span></div>
<div class="line">Widget j;</div>
<div class="line">std::tie(i, j) = MakeRelatedWidgets(cond);</div>
</div><!-- fragment --><p> This may be seen as an example of the <em>immediately initialize from input</em> exception below.</p>
<p>Creating optimal and equivalent code from all of these examples should be well within the capabilities of modern C++ compilers (but don't make performance claims without measuring; a compiler may very well not generate optimal code for every example and there may be language rules preventing some optimization that you would have liked in a particular case).</p>
<h4><a class="anchor" id="autotoc_md161"></a>
Example</h4>
<p>This rule covers member variables. </p><div class="fragment"><div class="line"><span class="keyword">class </span>X</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  X(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> i2) : m2{i}, m5{i2} {}</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> m1 = 7;</div>
<div class="line">  <span class="keywordtype">int</span> m2;</div>
<div class="line">  <span class="keywordtype">int</span> m3;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> m4 = 7;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> m5;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> m6;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The compiler will flag the uninitialized <code>m6</code> because it is a <code>const</code>, but it will not catch the lack of initialization of <code>m3</code>. Usually, a rare spurious member initialization is worth the absence of errors from lack of initialization and often an optimizer can eliminate a redundant initialization (e.g., an initialization that occurs immediately before an assignment).</p>
<h4><a class="anchor" id="autotoc_md162"></a>
Note</h4>
<p>Complex initialization has been popular with clever programmers for decades. It has also been a major source of errors and complexity. Many such errors are introduced during maintenance years after the initial implementation.</p>
<h4><a class="anchor" id="autotoc_md163"></a>
Exception</h4>
<p>If you are declaring an object that is just about to be initialized from input, initializing it would cause a double initialization. However, beware that this may leave uninitialized data beyond the input &ndash; and that has been a fertile source of errors and security breaches: </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> max = 8 * 1024;</div>
<div class="line"><span class="keywordtype">int</span> buf[max];         <span class="comment">// OK, but suspicious: uninitialized</span></div>
<div class="line">f.read(buf, max);</div>
</div><!-- fragment --><p> The cost of initializing that array could be significant in some situations. However, such examples do tend to leave uninitialized variables accessible, so they should be treated with suspicion. </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> max = 8 * 1024;</div>
<div class="line"><span class="keywordtype">int</span> buf[max] = {};   <span class="comment">// zero all elements; better in some situations</span></div>
<div class="line">f.read(buf, max);</div>
</div><!-- fragment --><p> When feasible use a library function that is known not to overflow. For example: </p><div class="fragment"><div class="line">std::string s;   <span class="comment">// s is default initialized to &quot;&quot;</span></div>
<div class="line">cin &gt;&gt; s;   <span class="comment">// s expands to hold the string</span></div>
</div><!-- fragment --><p> Don't consider simple variables that are targets for input operations exceptions to this rule: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;   <span class="comment">// bad</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">std::cin &gt;&gt; i;</div>
</div><!-- fragment --><p> In the not uncommon case where the input target and the input operation get separated (as they should not) the possibility of used-before-set opens up. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i2 = 0;   <span class="comment">// better</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">std::cin &gt;&gt; i;</div>
</div><!-- fragment --><p> A good optimizer should know about input operations and eliminate the redundant operation.</p>
<h4><a class="anchor" id="autotoc_md164"></a>
Example</h4>
<p>Using an <code>uninitialized</code> or sentinel value is a symptom of a problem and not a solution: </p><div class="fragment"><div class="line">Widget i = uninit;  <span class="comment">// bad</span></div>
<div class="line">Widget j = uninit;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">Use(i);         <span class="comment">// possibly used before set</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (cond)</div>
<div class="line">{     <span class="comment">// bad: i and j are initialized &quot;late&quot;</span></div>
<div class="line">  i = f1();</div>
<div class="line">  j = f2();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  i = f3();</div>
<div class="line">  j = f4();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Now the compiler cannot even simply detect a used-before-set. Further, we've introduced complexity in the state space for widget: which operations are valid on an <code>uninit</code> widget and which are not?</p>
<h4><a class="anchor" id="autotoc_md165"></a>
Note</h4>
<p>Sometimes, a lambda can be used as an initializer to avoid an uninitialized variable: </p><div class="fragment"><div class="line">error_code ec;</div>
<div class="line">Value v = [&amp;] {</div>
<div class="line">  <span class="keyword">auto</span> p = GetValue();   <span class="comment">// GetValue() returns a pair&lt;error_code, Value&gt;</span></div>
<div class="line">  ec = p.first;</div>
<div class="line">  <span class="keywordflow">return</span> p.second;</div>
<div class="line">}();</div>
</div><!-- fragment --><p> or maybe: </p><div class="fragment"><div class="line">Value v = [] {</div>
<div class="line">  <span class="keyword">auto</span> p = GetValue();   <span class="comment">// GetValue() returns a pair&lt;error_code, Value&gt;</span></div>
<div class="line">  <span class="keywordflow">if</span> (p.first) <span class="keywordflow">throw</span> BadValue{p.first};</div>
<div class="line">  <span class="keywordflow">return</span> p.second;</div>
<div class="line">}();</div>
</div><!-- fragment --><p> <b>See also</b>: <a href="#lambdainit">Use lambdas for complex initialization</a></p>
<h4><a class="anchor" id="autotoc_md166"></a>
Enforcement</h4>
<ul>
<li>Flag every uninitialized variable. Don't flag variables of user-defined types with default constructors.</li>
<li>Check that an uninitialized buffer is written into <em>immediately</em> after declaration. Passing an uninitialized variable as a reference to non-<code>const</code> argument can be assumed to be a write into the variable.</li>
</ul>
<h2><a class="anchor" id="autotoc_md167"></a>
&lt;a name="lambdainit"&gt;&lt;/a&gt; 21. Use lambdas for complex initialization, especially of &lt;tt&gt;const&lt;/tt&gt; variables</h2>
<h4><a class="anchor" id="autotoc_md168"></a>
Reason</h4>
<p>It nicely encapsulates local initialization, including cleaning up scratch variables needed only for the initialization, without needing to create a needless nonlocal yet nonreusable function. It also works for variables that should be <code>const</code> but only after some initialization work.</p>
<h4><a class="anchor" id="autotoc_md169"></a>
Example, bad</h4>
<div class="fragment"><div class="line">Widget x;   <span class="comment">// should be const, but:</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 2; i &lt;= N; ++i)              <span class="comment">// this could be some</span></div>
<div class="line">{</div>
<div class="line">  x += some_obj.do_something_with(i);  <span class="comment">// arbitrarily long code</span></div>
<div class="line">}                                        <span class="comment">// needed to initialize x</span></div>
<div class="line"><span class="comment">// from here, x should be const, but we can&#39;t say so in code in this style</span></div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md170"></a>
Example, good</h4>
<div class="fragment"><div class="line"><span class="keyword">const</span> Widget x = [&amp;]</div>
<div class="line">{</div>
<div class="line">  Widget val;                                <span class="comment">// assume that widget has a default constructor</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 2; i &lt;= N; ++i) {            <span class="comment">// this could be some</span></div>
<div class="line">    val += some_obj.do_something_with(i);  <span class="comment">// arbitrarily long code</span></div>
<div class="line">  }                                          <span class="comment">// needed to initialize x</span></div>
<div class="line">  <span class="keywordflow">return</span> val;</div>
<div class="line">}();</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md171"></a>
Example</h4>
<div class="fragment"><div class="line">std::string var = [&amp;]</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!in)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;   <span class="comment">// default</span></div>
<div class="line">  }</div>
<div class="line">  std::string s;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">char</span> c : in &gt;&gt; c)</div>
<div class="line">    s += toupper(c);</div>
<div class="line">  <span class="keywordflow">return</span> s;</div>
<div class="line">}(); <span class="comment">// note ()</span></div>
</div><!-- fragment --><p> If at all possible, reduce the conditions to a simple set of alternatives (e.g., an <code>enum</code>) and don't mix up selection and initialization.</p>
<h4><a class="anchor" id="autotoc_md172"></a>
Enforcement</h4>
<p>Hard. At best a heuristic. Look for an uninitialized variable followed by a loop assigning to it.</p>
<h2><a class="anchor" id="autotoc_md173"></a>
&lt;a name="orderctor"&gt;&lt;/a&gt; 22. Define and initialize member variables in the order of member declaration</h2>
<h4><a class="anchor" id="autotoc_md174"></a>
Reason</h4>
<p>To minimize confusion and errors. That is the order in which the initialization happens (independent of the order of member initializers).</p>
<h4><a class="anchor" id="autotoc_md175"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Foo(<span class="keywordtype">int</span> x) :m2{x}, m1{++x} { }   <span class="comment">// BAD: misleading initializer order</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> m1;</div>
<div class="line">  <span class="keywordtype">int</span> m2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Foo x(1); <span class="comment">// surprise: x.m1 == x.m2 == 2</span></div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md176"></a>
Enforcement</h4>
<p>(Simple) A member initializer list should mention the members in the same order they are declared.</p>
<h2><a class="anchor" id="autotoc_md177"></a>
&lt;a name="inclassinitializer"&gt;&lt;/a&gt; 23. Prefer in-class initializers to member initializers in constructors for constant initializers</h2>
<h4><a class="anchor" id="autotoc_md178"></a>
Reason</h4>
<p>Makes it explicit that the same value is expected to be used in all constructors. Avoids repetition. Avoids maintenance problems. It leads to the shortest and most efficient code.</p>
<h4><a class="anchor" id="autotoc_md179"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>X    <span class="comment">// BAD</span></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  X() :mI{666}, mS{<span class="stringliteral">&quot;qqq&quot;</span>} { }   <span class="comment">// j is uninitialized</span></div>
<div class="line">  X(<span class="keywordtype">int</span> ii) :mI{ii} {}         <span class="comment">// s is &quot;&quot; and j is uninitialized</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> mI;</div>
<div class="line">  <span class="keywordtype">string</span> mS;</div>
<div class="line">  <span class="keywordtype">int</span> mJ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> How would a maintainer know whether <code>mJ</code> was deliberately uninitialized (probably a poor idea anyway) and whether it was intentional to give <code>mS</code> the default value <code>""</code> in one case and <code>qqq</code> in another (almost certainly a bug)? The problem with <code>mJ</code> (forgetting to initialize a member) often happens when a new member is added to an existing class.</p>
<h4><a class="anchor" id="autotoc_md180"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>X2</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  X2() = <span class="keywordflow">default</span>;        <span class="comment">// all members are initialized to their defaults</span></div>
<div class="line">  X2(<span class="keywordtype">int</span> ii) :mI{ii} {}   <span class="comment">// s and j initialized to their defaults</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> mI {666};</div>
<div class="line">  <span class="keywordtype">string</span> mS {<span class="stringliteral">&quot;qqq&quot;</span>};</div>
<div class="line">  <span class="keywordtype">int</span> mJ {0};</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Alternative</b>: We can get part of the benefits from default arguments to constructors, and that is not uncommon in older code. However, that is less explicit, causes more arguments to be passed, and is repetitive when there is more than one constructor:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>X3</div>
<div class="line">{   <span class="comment">// BAD: inexplicit, argument passing overhead</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  X3(<span class="keywordtype">int</span> ii = 666, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; ss = <span class="stringliteral">&quot;qqq&quot;</span>, <span class="keywordtype">int</span> jj = 0)</div>
<div class="line">    :mI{ii}, mS{ss}, mJ{jj} { }   <span class="comment">// all members are initialized to their defaults</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> mI;</div>
<div class="line">  <span class="keywordtype">string</span> mS;</div>
<div class="line">  <span class="keywordtype">int</span> mJ;</div>
<div class="line">};</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md181"></a>
Enforcement</h4>
<ul>
<li>(Simple) Every constructor should initialize every member variable (either explicitly, via a delegating ctor call or via default construction).</li>
<li>(Simple) Default arguments to constructors suggest an in-class initializer may be more appropriate.</li>
</ul>
<h2><a class="anchor" id="autotoc_md182"></a>
&lt;a name="initializetoassignment"&gt;&lt;/a&gt; 24. Prefer initialization to assignment in constructors</h2>
<h4><a class="anchor" id="autotoc_md183"></a>
Reason</h4>
<p>An initialization explicitly states that initialization, rather than assignment, is done and can be more elegant and efficient. Prevents "use before set" errors.</p>
<h4><a class="anchor" id="autotoc_md184"></a>
Example, good</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>A</div>
<div class="line">{   <span class="comment">// Good</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  A() : mS1{<span class="stringliteral">&quot;Hello, &quot;</span>} { }    <span class="comment">// GOOD: directly construct</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">string</span> mS1;</div>
<div class="line">};</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md185"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>B</div>
<div class="line">{   <span class="comment">// BAD</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  B() { mS1 = <span class="stringliteral">&quot;Hello, &quot;</span>; }   <span class="comment">// BAD: default constructor followed by assignment</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">string</span> mS1;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>C</div>
<div class="line">{   <span class="comment">// UGLY, aka very bad</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  C() { cout &lt;&lt; *mP; mP = <span class="keyword">new</span> <span class="keywordtype">int</span>{10}; }   <span class="comment">// accidental use before initialized</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span>* mP;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md186"></a>
&lt;a name="castsnamed"&gt;&lt;/a&gt; 25. If you must use a cast, use a named cast</h2>
<h4><a class="anchor" id="autotoc_md187"></a>
Reason</h4>
<p>Readability. Error avoidance. Named casts are more specific than a C-style or functional cast, allowing the compiler to catch some errors.</p>
<p>The named casts are:</p>
<ul>
<li><code>static_cast</code></li>
<li><code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>dynamic_cast</code></li>
<li><code>std::move</code> // <code>move(x)</code> is an rvalue reference to <code>x</code></li>
<li><code>std::forward</code> // <code>forward(x)</code> is an rvalue reference to <code>x</code></li>
<li><code>gsl::narrow_cast</code> // <code>narrow_cast&lt;T&gt;(x)</code> is <code>static_cast&lt;T&gt;(x)</code></li>
<li><code>gsl::narrow</code> // <code>narrow&lt;T&gt;(x)</code> is <code>static_cast&lt;T&gt;(x)</code> if <code>static_cast&lt;T&gt;(x) == x</code> or it throws <code>narrowing_error</code></li>
</ul>
<h4><a class="anchor" id="autotoc_md188"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keyword">class </span>B { <span class="comment">/* ... */</span> };</div>
<div class="line"><span class="keyword">class </span>D { <span class="comment">/* ... */</span> };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> D&gt; D* upcast(B* pb)</div>
<div class="line">{</div>
<div class="line">  D* pd0 = pb;                        <span class="comment">// error: no implicit conversion from B* to D*</span></div>
<div class="line">  D* pd1 = (D*)pb;                    <span class="comment">// legal, but what is done?</span></div>
<div class="line">  D* pd2 = <span class="keyword">static_cast&lt;</span>D*<span class="keyword">&gt;</span>(pb);       <span class="comment">// error: D is not derived from B</span></div>
<div class="line">  D* pd3 = <span class="keyword">reinterpret_cast&lt;</span>D*<span class="keyword">&gt;</span>(pb);  <span class="comment">// OK: on your head be it!</span></div>
<div class="line">  D* pd4 = <span class="keyword">dynamic_cast&lt;</span>D*<span class="keyword">&gt;</span>(pb);      <span class="comment">// OK: return nullptr</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> The example was synthesized from real-world bugs where <code>D</code> used to be derived from <code>B</code>, but someone refactored the hierarchy. The C-style cast is dangerous because it can do any kind of conversion, depriving us of any protection from mistakes (now or in the future).</p>
<h4><a class="anchor" id="autotoc_md189"></a>
Note</h4>
<p>When converting between types with no information loss (e.g. from <code>float</code> to <code>double</code> or <code>int64</code> from <code>int32</code>), brace initialization may be used instead. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> d {some_float};</div>
<div class="line">int64_t i {some_int32};</div>
</div><!-- fragment --><p> This makes it clear that the type conversion was intended and also prevents conversions between types that might result in loss of precision. (It is a compilation error to try to initialize a <code>float</code> from a <code>double</code> in this fashion, for example.)</p>
<h4><a class="anchor" id="autotoc_md190"></a>
Note</h4>
<p><code>reinterpret_cast</code> can be essential, but the essential uses (e.g., turning a machine address into pointer) are not type safe: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> p = <span class="keyword">reinterpret_cast&lt;</span>Device_register<span class="keyword">&gt;</span>(0x800);  <span class="comment">// inherently dangerous</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md191"></a>
Enforcement</h4>
<ul>
<li>Flag C-style and functional casts.</li>
<li>The <a href="#Pro-type-reinterpretcast">type profile</a> bans <code>reinterpret_cast</code>.</li>
<li>The <a href="#Pro-type-arithmeticcast">type profile</a> warns when using <code>static_cast</code> between arithmetic types.</li>
</ul>
<h2><a class="anchor" id="autotoc_md192"></a>
&lt;a name="castsconst"&gt;&lt;/a&gt; 26. Don't cast away &lt;tt&gt;const&lt;/tt&gt;</h2>
<h4><a class="anchor" id="autotoc_md193"></a>
Reason</h4>
<p>It makes a lie out of <code>const</code>. If the variable is actually declared <code>const</code>, the result of "casting away `const`" is undefined behavior.</p>
<h4><a class="anchor" id="autotoc_md194"></a>
Example, bad</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const_cast&lt;</span><span class="keywordtype">int</span>&amp;<span class="keyword">&gt;</span>(i) = 42;   <span class="comment">// BAD</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> i = 0;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> j = 0;</div>
<div class="line"> </div>
<div class="line">f(i); <span class="comment">// silent side effect</span></div>
<div class="line">f(j); <span class="comment">// undefined behavior</span></div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md195"></a>
Example</h4>
<p>Sometimes, you may be tempted to resort to <code>const_cast</code> to avoid code duplication, such as when two accessor functions that differ only in <code>const</code>-ness have similar implementations. For example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Bar;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Foo</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// BAD, duplicates logic</span></div>
<div class="line">  Bar&amp; GetBar() {</div>
<div class="line">    <span class="comment">/* complex logic around getting a non-const reference to mBar */</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> Bar&amp; GetBar()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="comment">/* same complex logic around getting a const reference to mBar */</span></div>
<div class="line">  }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Bar mBar;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Instead, prefer to share implementations. Normally, you can just have the non-<code>const</code> function call the <code>const</code> function. However, when there is complex logic this can lead to the following pattern that still resorts to a <code>const_cast</code>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// not great, non-const calls const version but resorts to const_cast</span></div>
<div class="line">  Bar&amp; GetBar() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>Bar&amp;<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Foo&amp;<span class="keyword">&gt;</span>(*this).GetBar());</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">const</span> Bar&amp; GetBar()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="comment">/* the complex logic around getting a const reference to mBar */</span></div>
<div class="line">  }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Bar mBar;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Although this pattern is safe when applied correctly, because the caller must have had a non-<code>const</code> object to begin with, it's not ideal because the safety is hard to enforce automatically as a checker rule.</p>
<p>Instead, prefer to put the common code in a common helper function &ndash; and make it a template so that it deduces <code>const</code>. This doesn't use any <code>const_cast</code> at all: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:                         <span class="comment">// good</span></div>
<div class="line">      Bar&amp; GetBar()       { <span class="keywordflow">return</span> GetBarImpl(*<span class="keyword">this</span>); }</div>
<div class="line">  <span class="keyword">const</span> Bar&amp; GetBar()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> GetBarImpl(*<span class="keyword">this</span>); }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Bar mBar;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;           <span class="comment">// good, deduces whether T is const or non-const</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> GetBarImpl(T&amp; t) -&gt; decltype(t.GetBar())</div>
<div class="line">    { <span class="comment">/* the complex logic around getting a possibly-const reference to mBar */</span> }</div>
<div class="line">};</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md196"></a>
Exception</h4>
<p>You may need to cast away <code>const</code> when calling <code>const</code>-incorrect functions. Prefer to wrap such functions in inline <code>const</code>-correct wrappers to encapsulate the cast in one place.</p>
<h4><a class="anchor" id="autotoc_md197"></a>
Example</h4>
<p>Sometimes, "cast away `const`" is to allow the updating of some transient information of an otherwise immutable object. Examples are caching, memoization, and precomputation. Such examples are often handled as well or better using <code>mutable</code> or an indirection than with a <code>const_cast</code>.</p>
<p>Consider keeping previously computed results around for a costly operation: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> Compute(<span class="keywordtype">int</span> x); <span class="comment">// compute a value for x; assume this to be costly</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Cache</div>
<div class="line">{   <span class="comment">// some type implementing a cache for an int-&gt;int operation</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  pair&lt;bool, int&gt; Find(<span class="keywordtype">int</span> x) <span class="keyword">const</span>;   <span class="comment">// is there a value for x?</span></div>
<div class="line">  <span class="keywordtype">void</span> Set(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> v);             <span class="comment">// make y the value for x</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>X</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">int</span> GetVal(<span class="keywordtype">int</span> x)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> p = cache.Find(x);</div>
<div class="line">    <span class="keywordflow">if</span> (p.first) <span class="keywordflow">return</span> p.second;</div>
<div class="line">    <span class="keywordtype">int</span> val = Compute(x);</div>
<div class="line">    cache.Set(x, val); <span class="comment">// insert value for x</span></div>
<div class="line">    <span class="keywordflow">return</span> val;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Cache cache;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Here, <code>GetVal()</code> is logically constant, so we would like to make it a <code>const</code> member. To do this we still need to mutate <code>cache</code>, so people sometimes resort to a <code>const_cast</code>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>X</div>
<div class="line">{   <span class="comment">// Suspicious solution based on casting</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">int</span> GetVal(<span class="keywordtype">int</span> x)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">auto</span> p = cache.Find(x);</div>
<div class="line">    <span class="keywordflow">if</span> (p.first) <span class="keywordflow">return</span> p.second;</div>
<div class="line">    <span class="keywordtype">int</span> val = Compute(x);</div>
<div class="line">    <span class="keyword">const_cast&lt;</span>Cache&amp;<span class="keyword">&gt;</span>(cache).Set(x, val);   <span class="comment">// ugly</span></div>
<div class="line">    <span class="keywordflow">return</span> val;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Cache cache;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Fortunately, there is a better solution: State that <code>cache</code> is mutable even for a <code>const</code> object: </p><div class="fragment"><div class="line"><span class="keyword">class </span>X</div>
<div class="line">{   <span class="comment">// better solution</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">int</span> GetVal(<span class="keywordtype">int</span> x)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">auto</span> p = cache.Find(x);</div>
<div class="line">    <span class="keywordflow">if</span> (p.first) <span class="keywordflow">return</span> p.second;</div>
<div class="line">    <span class="keywordtype">int</span> val = Compute(x);</div>
<div class="line">    cache.Set(x, val);</div>
<div class="line">    <span class="keywordflow">return</span> val;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">mutable</span> Cache cache;</div>
<div class="line">};</div>
</div><!-- fragment --><p> An alternative solution would to store a pointer to the <code>cache</code>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>X</div>
<div class="line">{   <span class="comment">// OK, but slightly messier solution</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">int</span> GetVal(<span class="keywordtype">int</span> x)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">auto</span> p = cache-&gt;Find(x);</div>
<div class="line">    <span class="keywordflow">if</span> (p.first) <span class="keywordflow">return</span> p.second;</div>
<div class="line">    <span class="keywordtype">int</span> val = Compute(x);</div>
<div class="line">    cache-&gt;Set(x, val);</div>
<div class="line">    <span class="keywordflow">return</span> val;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  unique_ptr&lt;Cache&gt; cache;</div>
<div class="line">};</div>
</div><!-- fragment --><p> That solution is the most flexible, but requires explicit construction and destruction of <code>*cache</code> (most likely in the constructor and destructor of <code>X</code>).</p>
<p>In any variant, we must guard against data races on the <code>cache</code> in multi-threaded code, possibly using a <code>std::mutex</code>.</p>
<h4><a class="anchor" id="autotoc_md198"></a>
Enforcement</h4>
<ul>
<li>Flag <code>const_cast</code>s.</li>
<li>This rule is part of the <a href="#Pro-type-constcast">type-safety profile</a> for the related Profile.</li>
</ul>
<h2><a class="anchor" id="autotoc_md199"></a>
&lt;a name="symmetric"&gt;&lt;/a&gt; 27. Use nonmember functions for symmetric operators</h2>
<h4><a class="anchor" id="autotoc_md200"></a>
Reason</h4>
<p>If you use member functions, you need two. Unless you use a nonmember function for (say) <code>==</code>, <code>a == b</code> and <code>b == a</code> will be subtly different.</p>
<h4><a class="anchor" id="autotoc_md201"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="namespacedev_1_1p2p.html#a1b068440ef1dbbeea042bc9c91b14877">operator==</a>(Point a, Point b) { <span class="keywordflow">return</span> a.x == b.x &amp;&amp; a.y == b.y; }</div>
<div class="ttc" id="anamespacedev_1_1p2p_html_a1b068440ef1dbbeea042bc9c91b14877"><div class="ttname"><a href="namespacedev_1_1p2p.html#a1b068440ef1dbbeea042bc9c91b14877">dev::p2p::operator==</a></div><div class="ttdeci">bool operator==(weak_ptr&lt; NodeEntry &gt; const &amp;_weak, shared_ptr&lt; NodeEntry &gt; const &amp;_shared)</div><div class="ttdef"><b>Definition:</b> NodeTable.cpp:31</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md202"></a>
Note</h4>
<p><em>When to use a normal, friend, or member function overload?</em></p>
<p>In most cases, the language leaves it up to you to determine whether you want to use the normal/friend or member function version of the overload. However, one of the two is usually a better choice than the other. When dealing with binary operators that don't modify the left operand (e.g. operator+), the normal or friend function version is typically preferred, because it works for all parameter types (even when the left operand isn't a class object, or is a class that is not modifiable). The normal or friend function version has the added benefit of "symmetry", as all operands become explicit parameters (instead of the left operand becoming *this and the right operand becoming an explicit parameter). When dealing with binary operators that do modify the left operand (e.g. operator+=), the member function version is typically preferred. In these cases, the leftmost operand will always be a class type, and having the object being modified become the one pointed to by *this is natural. Because the rightmost operand becomes an explicit parameter, there's no confusion over who is getting modified and who is getting evaluated. Unary operators are usually overloaded as member functions as well, since the member version has no parameters.</p>
<p>The following rules of thumb can help you determine which form is best for a given situation:</p>
<ul>
<li>If you're overloading assignment (=), subscript ([]), function call (()), or member selection (-&gt;), do so as a <b>member function</b>.</li>
<li>If you're overloading a unary operator, do so as a <b>member function</b>.</li>
<li>If you're overloading a binary operator that modifies its left operand (e.g. operator+=), do so as a <b>member function</b> if you can.</li>
<li>If you're overloading a binary operator that does not modify its left operand (e.g. operator+), do so as a <b>normal function</b> or <b>friend function</b>.</li>
</ul>
<blockquote class="doxtable">
<p><b>Not everything can be overloaded as a friend function</b> The assignment (=), subscript ([]), function call (()), and member selection (-&gt;) operators must be overloaded as member functions, because the language requires them to be. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>Not everything can be overloaded as a member function</b> Overloading the I/O operators, we overloaded operator&lt;&lt; for our Point class using the friend function method. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md203"></a>
Enforcement</h4>
<p>Flag member operator functions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
