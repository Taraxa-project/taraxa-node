// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#pragma once

#ifndef TARAXASCHEMA_H
#define TARAXASCHEMA_H

#include "graphqlservice/internal/Schema.h"

// Check if the library version is compatible with schemagen 4.5.0
static_assert(graphql::internal::MajorVersion == 4, "regenerate with schemagen: major version mismatch");
static_assert(graphql::internal::MinorVersion == 5, "regenerate with schemagen: minor version mismatch");

#include <array>
#include <memory>
#include <string>
#include <string_view>

namespace graphql {
namespace taraxa {

struct [[nodiscard]] BlockFilterCriteria
{
	explicit BlockFilterCriteria(
		std::optional<std::vector<response::Value>> addressesArg = std::optional<std::vector<response::Value>> {},
		std::optional<std::vector<std::vector<response::Value>>> topicsArg = std::optional<std::vector<std::vector<response::Value>>> {}) noexcept;
	BlockFilterCriteria(const BlockFilterCriteria& other);
	BlockFilterCriteria(BlockFilterCriteria&& other) noexcept;

	BlockFilterCriteria& operator=(const BlockFilterCriteria& other);
	BlockFilterCriteria& operator=(BlockFilterCriteria&& other) noexcept;

	std::optional<std::vector<response::Value>> addresses {};
	std::optional<std::vector<std::vector<response::Value>>> topics {};
};

struct [[nodiscard]] CallData
{
	explicit CallData(
		std::optional<response::Value> fromArg = std::optional<response::Value> {},
		std::optional<response::Value> toArg = std::optional<response::Value> {},
		std::optional<response::Value> gasArg = std::optional<response::Value> {},
		std::optional<response::Value> gasPriceArg = std::optional<response::Value> {},
		std::optional<response::Value> valueArg = std::optional<response::Value> {},
		std::optional<response::Value> dataArg = std::optional<response::Value> {}) noexcept;
	CallData(const CallData& other);
	CallData(CallData&& other) noexcept;

	CallData& operator=(const CallData& other);
	CallData& operator=(CallData&& other) noexcept;

	std::optional<response::Value> from {};
	std::optional<response::Value> to {};
	std::optional<response::Value> gas {};
	std::optional<response::Value> gasPrice {};
	std::optional<response::Value> value {};
	std::optional<response::Value> data {};
};

struct [[nodiscard]] FilterCriteria
{
	explicit FilterCriteria(
		std::optional<response::Value> fromBlockArg = std::optional<response::Value> {},
		std::optional<response::Value> toBlockArg = std::optional<response::Value> {},
		std::optional<std::vector<response::Value>> addressesArg = std::optional<std::vector<response::Value>> {},
		std::optional<std::vector<std::vector<response::Value>>> topicsArg = std::optional<std::vector<std::vector<response::Value>>> {}) noexcept;
	FilterCriteria(const FilterCriteria& other);
	FilterCriteria(FilterCriteria&& other) noexcept;

	FilterCriteria& operator=(const FilterCriteria& other);
	FilterCriteria& operator=(FilterCriteria&& other) noexcept;

	std::optional<response::Value> fromBlock {};
	std::optional<response::Value> toBlock {};
	std::optional<std::vector<response::Value>> addresses {};
	std::optional<std::vector<std::vector<response::Value>>> topics {};
};

namespace object {

class Account;
class Log;
class Transaction;
class DagBlock;
class Block;
class CallResult;
class SyncState;
class Pending;
class CurrentState;
class Query;
class Mutation;
class Subscription;

} // namespace object

class [[nodiscard]] Operations final
	: public service::Request
{
public:
	explicit Operations(std::shared_ptr<object::Query> query, std::shared_ptr<object::Mutation> mutation, std::shared_ptr<object::Subscription> subscription);

	template <class TQuery, class TMutation, class TSubscription = service::SubscriptionPlaceholder>
	explicit Operations(std::shared_ptr<TQuery> query, std::shared_ptr<TMutation> mutation, std::shared_ptr<TSubscription> subscription = {})
		: Operations {
			std::make_shared<object::Query>(std::move(query)),
			std::make_shared<object::Mutation>(std::move(mutation)),
			subscription ? std::make_shared<object::Subscription>(std::move(subscription)) : std::shared_ptr<object::Subscription> {}
		}
	{
	}

private:
	std::shared_ptr<object::Query> _query;
	std::shared_ptr<object::Mutation> _mutation;
	std::shared_ptr<object::Subscription> _subscription;
};

void AddAccountDetails(const std::shared_ptr<schema::ObjectType>& typeAccount, const std::shared_ptr<schema::Schema>& schema);
void AddLogDetails(const std::shared_ptr<schema::ObjectType>& typeLog, const std::shared_ptr<schema::Schema>& schema);
void AddTransactionDetails(const std::shared_ptr<schema::ObjectType>& typeTransaction, const std::shared_ptr<schema::Schema>& schema);
void AddDagBlockDetails(const std::shared_ptr<schema::ObjectType>& typeDagBlock, const std::shared_ptr<schema::Schema>& schema);
void AddBlockDetails(const std::shared_ptr<schema::ObjectType>& typeBlock, const std::shared_ptr<schema::Schema>& schema);
void AddCallResultDetails(const std::shared_ptr<schema::ObjectType>& typeCallResult, const std::shared_ptr<schema::Schema>& schema);
void AddSyncStateDetails(const std::shared_ptr<schema::ObjectType>& typeSyncState, const std::shared_ptr<schema::Schema>& schema);
void AddPendingDetails(const std::shared_ptr<schema::ObjectType>& typePending, const std::shared_ptr<schema::Schema>& schema);
void AddCurrentStateDetails(const std::shared_ptr<schema::ObjectType>& typeCurrentState, const std::shared_ptr<schema::Schema>& schema);
void AddQueryDetails(const std::shared_ptr<schema::ObjectType>& typeQuery, const std::shared_ptr<schema::Schema>& schema);
void AddMutationDetails(const std::shared_ptr<schema::ObjectType>& typeMutation, const std::shared_ptr<schema::Schema>& schema);
void AddSubscriptionDetails(const std::shared_ptr<schema::ObjectType>& typeSubscription, const std::shared_ptr<schema::Schema>& schema);

std::shared_ptr<schema::Schema> GetSchema();

} // namespace taraxa
} // namespace graphql

#endif // TARAXASCHEMA_H
