apiVersion: v1
kind: ConfigMap
metadata:
  name: "{{ include "taraxa-node.fullname" . }}-service-registry"
  labels:
    app: service-registry
    app.kubernetes.io/name: {{ include "taraxa-node.name" . }}
    helm.sh/chart: {{ include "taraxa-node.chart" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    release: {{ .Release.Name }}
data:
  requirements.txt: |-
    cachetools==5.2.0
    certifi==2022.9.14
    charset-normalizer==2.1.1
    google-auth==2.11.1
    idna==3.4
    kubernetes==24.2.0
    oauthlib==3.2.1
    pyasn1==0.4.8
    pyasn1-modules==0.2.8
    python-dateutil==2.8.2
    PyYAML==6.0
    requests==2.28.1
    requests-oauthlib==1.3.1
    rsa==4.9
    six==1.16.0
    urllib3==1.26.12
    websocket-client==1.4.1

  app.py: |-
    import time
    import logging
    import os
    import threading
    import json
    import requests
    from requests.exceptions import HTTPError
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from kubernetes import client, config

    logging.basicConfig(level=logging.INFO)

    logging.info('Starting registry service...')

    try:
        config.load_incluster_config()
    except config.ConfigException:
        try:
            config.load_kube_config()
        except config.ConfigException:
            raise Exception("Could not configure kubernetes python client")


    def get_current_namespace():
        ns_path = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"
        if os.path.exists(ns_path):
            with open(ns_path) as f:
                return f.read().strip()
        try:
            _, active_context = config.list_kube_config_contexts()
            return active_context["context"]["namespace"]
        except KeyError:
            return "default"


    instance = "{{ .Release.Name }}"
    namespace = get_current_namespace()
    logging.info('Current namespace: {}'.format(namespace))

    v1 = client.CoreV1Api()


    def is_pod_valid(pod):
        if "app.kubernetes.io/instance" not in pod.metadata.labels:
            return False
        if pod.metadata.labels["app.kubernetes.io/instance"] != instance:
            return False
        if "app" not in pod.metadata.labels:
            return False
        if pod.metadata.labels["app"] not in ["boot-node", "consensus-node", "taraxa-node"]:
            return False
        if pod.status.conditions is None:
            return False

        for condition in pod.status.conditions:
            if condition.type == 'Ready' and condition.status == 'True':
                return True

        return False


    def get_pods_sync():
        namespaced_pods = v1.list_namespaced_pod(
            namespace=namespace, watch=False)

        pods = []
        for i in namespaced_pods.items:
            if is_pod_valid(i):
                pods.append({
                    "type": i.metadata.labels["app"],
                    "instance": i.metadata.labels["app.kubernetes.io/instance"],
                    "name": i.metadata.name,
                    "ip": i.status.pod_ip
                })

        return pods


    def watch_pods():
        namespaced_pods = v1.list_namespaced_pod(
            namespace="blockchain-prnet", watch=False)

        pods = []
        for i in namespaced_pods.items:
            if is_pod_valid(i):
                pods.append({
                    "type": i.metadata.labels["app"],
                    "instance": i.metadata.labels["app.kubernetes.io/instance"],
                    "name": i.metadata.name,
                    "ip": i.status.pod_ip
                })

        return pods


    def get_pod_wallet_address(pod):
        name = pod['name']
        ip = pod['ip']
        try:
            response = requests.post('http://{}:7777/'.format(ip), json={
                                    'jsonrpc': '2.0', 'method': 'get_account_address', 'params': [], 'id': 1})
            response.raise_for_status()

            json = response.json()
            return '0x{}'.format(json['result']['value'])
        except HTTPError as http_err:
            logging.warning(
                f'Get pod address for {name}: HTTP error occurred: {http_err}')
        except Exception as err:
            logging.warning(
                f'Get pod address for {name}: Other error occurred: {err}')


    def update_pods(pods):
        pods = []
        for p in get_pods_sync():
            if p['type'] != "boot-node":
                address = get_pod_wallet_address(p)
                if address is None:
                    logging.warning('Could not get wallet address for pod {}, ip: {}'.format(
                        p['name'], p['ip']))
            else:
                address = None

            p['address'] = address
            logging.info('Found pod: {}'.format(p))
            pods.append(p)
        return pods


    pods = []


    def listen():
        global pods
        while True:
            pods = update_pods(pods)
            time.sleep(20)


    hostName = "127.0.0.1"
    serverPort = 5000


    class RegistryServer(BaseHTTPRequestHandler):
        def do_GET(self):
            self.send_response(200)
            self.send_header("Content-type", "application/json")
            self.end_headers()
            self.wfile.write(bytes(json.dumps(pods), "utf-8"))


    if __name__ == '__main__':
        thread = threading.Thread(target=listen)
        thread.start()

        server = HTTPServer((hostName, serverPort), RegistryServer)
        print("Server started http://%s:%s" % (hostName, serverPort))

        try:
            server.serve_forever()
        except KeyboardInterrupt:
            pass

        server.server_close()
        print("Server stopped.")