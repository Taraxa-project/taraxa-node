// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: proto/ledger.proto
#ifndef GRPC_proto_2fledger_2eproto__INCLUDED
#define GRPC_proto_2fledger_2eproto__INCLUDED

#include "proto/ledger.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace ledger {

class LedgerService final {
 public:
  static constexpr char const* service_full_name() {
    return "ledger.LedgerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status IsTestnet(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::IsTestnetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::IsTestnetResponse>> AsyncIsTestnet(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::IsTestnetResponse>>(AsyncIsTestnetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::IsTestnetResponse>> PrepareAsyncIsTestnet(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::IsTestnetResponse>>(PrepareAsyncIsTestnetRaw(context, request, cq));
    }
    virtual ::grpc::Status GetNetworkName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetNetworkNameResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetNetworkNameResponse>> AsyncGetNetworkName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetNetworkNameResponse>>(AsyncGetNetworkNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetNetworkNameResponse>> PrepareAsyncGetNetworkName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetNetworkNameResponse>>(PrepareAsyncGetNetworkNameRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSubversion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetSubversionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetSubversionResponse>> AsyncGetSubversion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetSubversionResponse>>(AsyncGetSubversionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetSubversionResponse>> PrepareAsyncGetSubversion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetSubversionResponse>>(PrepareAsyncGetSubversionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCoinName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetCoinNameResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetCoinNameResponse>> AsyncGetCoinName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetCoinNameResponse>>(AsyncGetCoinNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetCoinNameResponse>> PrepareAsyncGetCoinName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetCoinNameResponse>>(PrepareAsyncGetCoinNameRaw(context, request, cq));
    }
    virtual ::grpc::Status GetChainInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetChainInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetChainInfoResponse>> AsyncGetChainInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetChainInfoResponse>>(AsyncGetChainInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetChainInfoResponse>> PrepareAsyncGetChainInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetChainInfoResponse>>(PrepareAsyncGetChainInfoRaw(context, request, cq));
    }
    //
    //
    // Ledger/Blockchain RPC API
    // This section will be outlining the ledger/blockchain
    // specific requests.
    //
    // GetBestBlockHash - get the current chain tip hash
    // GetBestBlockHeight - get the current chain tip height
    // GetBlockHash(height uint64) - get the specified block hash
    // GetBlockHeader(hash string) - get the header for the specified block hash
    // GetBlock(hash string) - get the block with the specified hash
    // GetBlockInfo(hash string) - get the block metadata for the specified block hash
    //
    //
    virtual ::grpc::Status GetBestBlockHash(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetBestBlockHashResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHashResponse>> AsyncGetBestBlockHash(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHashResponse>>(AsyncGetBestBlockHashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHashResponse>> PrepareAsyncGetBestBlockHash(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHashResponse>>(PrepareAsyncGetBestBlockHashRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBestBlockHeight(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetBestBlockHeightResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHeightResponse>> AsyncGetBestBlockHeight(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHeightResponse>>(AsyncGetBestBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHeightResponse>> PrepareAsyncGetBestBlockHeight(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHeightResponse>>(PrepareAsyncGetBestBlockHeightRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockHash(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest& request, ::ledger::GetBlockHashResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHashResponse>> AsyncGetBlockHash(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHashResponse>>(AsyncGetBlockHashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHashResponse>> PrepareAsyncGetBlockHash(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHashResponse>>(PrepareAsyncGetBlockHashRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockHeader(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest& request, ::ledger::GetBlockHeaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHeaderResponse>> AsyncGetBlockHeader(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHeaderResponse>>(AsyncGetBlockHeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHeaderResponse>> PrepareAsyncGetBlockHeader(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHeaderResponse>>(PrepareAsyncGetBlockHeaderRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlock(::grpc::ClientContext* context, const ::ledger::GetBlockRequest& request, ::ledger::GetBlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockResponse>> AsyncGetBlock(::grpc::ClientContext* context, const ::ledger::GetBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockResponse>>(AsyncGetBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockResponse>> PrepareAsyncGetBlock(::grpc::ClientContext* context, const ::ledger::GetBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockResponse>>(PrepareAsyncGetBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockInfo(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest& request, ::ledger::GetBlockInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockInfoResponse>> AsyncGetBlockInfo(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockInfoResponse>>(AsyncGetBlockInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockInfoResponse>> PrepareAsyncGetBlockInfo(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockInfoResponse>>(PrepareAsyncGetBlockInfoRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void IsTestnet(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::IsTestnetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetNetworkName(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetNetworkNameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSubversion(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetSubversionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCoinName(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetCoinNameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetChainInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetChainInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      //
      //
      // Ledger/Blockchain RPC API
      // This section will be outlining the ledger/blockchain
      // specific requests.
      //
      // GetBestBlockHash - get the current chain tip hash
      // GetBestBlockHeight - get the current chain tip height
      // GetBlockHash(height uint64) - get the specified block hash
      // GetBlockHeader(hash string) - get the header for the specified block hash
      // GetBlock(hash string) - get the block with the specified hash
      // GetBlockInfo(hash string) - get the block metadata for the specified block hash
      //
      //
      virtual void GetBestBlockHash(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHashResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBestBlockHeight(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHeightResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockHash(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest* request, ::ledger::GetBlockHashResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockHeader(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest* request, ::ledger::GetBlockHeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlock(::grpc::ClientContext* context, const ::ledger::GetBlockRequest* request, ::ledger::GetBlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBlockInfo(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest* request, ::ledger::GetBlockInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::IsTestnetResponse>* AsyncIsTestnetRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::IsTestnetResponse>* PrepareAsyncIsTestnetRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetNetworkNameResponse>* AsyncGetNetworkNameRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetNetworkNameResponse>* PrepareAsyncGetNetworkNameRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetSubversionResponse>* AsyncGetSubversionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetSubversionResponse>* PrepareAsyncGetSubversionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetCoinNameResponse>* AsyncGetCoinNameRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetCoinNameResponse>* PrepareAsyncGetCoinNameRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetChainInfoResponse>* AsyncGetChainInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetChainInfoResponse>* PrepareAsyncGetChainInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHashResponse>* AsyncGetBestBlockHashRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHashResponse>* PrepareAsyncGetBestBlockHashRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHeightResponse>* AsyncGetBestBlockHeightRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBestBlockHeightResponse>* PrepareAsyncGetBestBlockHeightRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHashResponse>* AsyncGetBlockHashRaw(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHashResponse>* PrepareAsyncGetBlockHashRaw(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHeaderResponse>* AsyncGetBlockHeaderRaw(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockHeaderResponse>* PrepareAsyncGetBlockHeaderRaw(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockResponse>* AsyncGetBlockRaw(::grpc::ClientContext* context, const ::ledger::GetBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockResponse>* PrepareAsyncGetBlockRaw(::grpc::ClientContext* context, const ::ledger::GetBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockInfoResponse>* AsyncGetBlockInfoRaw(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ledger::GetBlockInfoResponse>* PrepareAsyncGetBlockInfoRaw(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status IsTestnet(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::IsTestnetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::IsTestnetResponse>> AsyncIsTestnet(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::IsTestnetResponse>>(AsyncIsTestnetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::IsTestnetResponse>> PrepareAsyncIsTestnet(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::IsTestnetResponse>>(PrepareAsyncIsTestnetRaw(context, request, cq));
    }
    ::grpc::Status GetNetworkName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetNetworkNameResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetNetworkNameResponse>> AsyncGetNetworkName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetNetworkNameResponse>>(AsyncGetNetworkNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetNetworkNameResponse>> PrepareAsyncGetNetworkName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetNetworkNameResponse>>(PrepareAsyncGetNetworkNameRaw(context, request, cq));
    }
    ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    ::grpc::Status GetSubversion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetSubversionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetSubversionResponse>> AsyncGetSubversion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetSubversionResponse>>(AsyncGetSubversionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetSubversionResponse>> PrepareAsyncGetSubversion(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetSubversionResponse>>(PrepareAsyncGetSubversionRaw(context, request, cq));
    }
    ::grpc::Status GetCoinName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetCoinNameResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetCoinNameResponse>> AsyncGetCoinName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetCoinNameResponse>>(AsyncGetCoinNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetCoinNameResponse>> PrepareAsyncGetCoinName(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetCoinNameResponse>>(PrepareAsyncGetCoinNameRaw(context, request, cq));
    }
    ::grpc::Status GetChainInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetChainInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetChainInfoResponse>> AsyncGetChainInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetChainInfoResponse>>(AsyncGetChainInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetChainInfoResponse>> PrepareAsyncGetChainInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetChainInfoResponse>>(PrepareAsyncGetChainInfoRaw(context, request, cq));
    }
    ::grpc::Status GetBestBlockHash(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetBestBlockHashResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHashResponse>> AsyncGetBestBlockHash(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHashResponse>>(AsyncGetBestBlockHashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHashResponse>> PrepareAsyncGetBestBlockHash(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHashResponse>>(PrepareAsyncGetBestBlockHashRaw(context, request, cq));
    }
    ::grpc::Status GetBestBlockHeight(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::ledger::GetBestBlockHeightResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHeightResponse>> AsyncGetBestBlockHeight(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHeightResponse>>(AsyncGetBestBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHeightResponse>> PrepareAsyncGetBestBlockHeight(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHeightResponse>>(PrepareAsyncGetBestBlockHeightRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHash(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest& request, ::ledger::GetBlockHashResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHashResponse>> AsyncGetBlockHash(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHashResponse>>(AsyncGetBlockHashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHashResponse>> PrepareAsyncGetBlockHash(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHashResponse>>(PrepareAsyncGetBlockHashRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHeader(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest& request, ::ledger::GetBlockHeaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHeaderResponse>> AsyncGetBlockHeader(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHeaderResponse>>(AsyncGetBlockHeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHeaderResponse>> PrepareAsyncGetBlockHeader(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHeaderResponse>>(PrepareAsyncGetBlockHeaderRaw(context, request, cq));
    }
    ::grpc::Status GetBlock(::grpc::ClientContext* context, const ::ledger::GetBlockRequest& request, ::ledger::GetBlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockResponse>> AsyncGetBlock(::grpc::ClientContext* context, const ::ledger::GetBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockResponse>>(AsyncGetBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockResponse>> PrepareAsyncGetBlock(::grpc::ClientContext* context, const ::ledger::GetBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockResponse>>(PrepareAsyncGetBlockRaw(context, request, cq));
    }
    ::grpc::Status GetBlockInfo(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest& request, ::ledger::GetBlockInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockInfoResponse>> AsyncGetBlockInfo(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockInfoResponse>>(AsyncGetBlockInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockInfoResponse>> PrepareAsyncGetBlockInfo(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockInfoResponse>>(PrepareAsyncGetBlockInfoRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void IsTestnet(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::IsTestnetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetNetworkName(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetNetworkNameResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVersion(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSubversion(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetSubversionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCoinName(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetCoinNameResponse* response, std::function<void(::grpc::Status)>) override;
      void GetChainInfo(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetChainInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBestBlockHash(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHashResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBestBlockHeight(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHeightResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlockHash(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest* request, ::ledger::GetBlockHashResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlockHeader(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest* request, ::ledger::GetBlockHeaderResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlock(::grpc::ClientContext* context, const ::ledger::GetBlockRequest* request, ::ledger::GetBlockResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBlockInfo(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest* request, ::ledger::GetBlockInfoResponse* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ledger::IsTestnetResponse>* AsyncIsTestnetRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::IsTestnetResponse>* PrepareAsyncIsTestnetRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetNetworkNameResponse>* AsyncGetNetworkNameRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetNetworkNameResponse>* PrepareAsyncGetNetworkNameRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetSubversionResponse>* AsyncGetSubversionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetSubversionResponse>* PrepareAsyncGetSubversionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetCoinNameResponse>* AsyncGetCoinNameRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetCoinNameResponse>* PrepareAsyncGetCoinNameRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetChainInfoResponse>* AsyncGetChainInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetChainInfoResponse>* PrepareAsyncGetChainInfoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHashResponse>* AsyncGetBestBlockHashRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHashResponse>* PrepareAsyncGetBestBlockHashRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHeightResponse>* AsyncGetBestBlockHeightRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBestBlockHeightResponse>* PrepareAsyncGetBestBlockHeightRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHashResponse>* AsyncGetBlockHashRaw(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHashResponse>* PrepareAsyncGetBlockHashRaw(::grpc::ClientContext* context, const ::ledger::GetBlockHashRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHeaderResponse>* AsyncGetBlockHeaderRaw(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockHeaderResponse>* PrepareAsyncGetBlockHeaderRaw(::grpc::ClientContext* context, const ::ledger::GetBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockResponse>* AsyncGetBlockRaw(::grpc::ClientContext* context, const ::ledger::GetBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockResponse>* PrepareAsyncGetBlockRaw(::grpc::ClientContext* context, const ::ledger::GetBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockInfoResponse>* AsyncGetBlockInfoRaw(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ledger::GetBlockInfoResponse>* PrepareAsyncGetBlockInfoRaw(::grpc::ClientContext* context, const ::ledger::GetBlockInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_IsTestnet_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNetworkName_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSubversion_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCoinName_;
    const ::grpc::internal::RpcMethod rpcmethod_GetChainInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBestBlockHash_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBestBlockHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHash_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHeader_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockInfo_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status IsTestnet(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::IsTestnetResponse* response);
    virtual ::grpc::Status GetNetworkName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetNetworkNameResponse* response);
    virtual ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetVersionResponse* response);
    virtual ::grpc::Status GetSubversion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetSubversionResponse* response);
    virtual ::grpc::Status GetCoinName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetCoinNameResponse* response);
    virtual ::grpc::Status GetChainInfo(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetChainInfoResponse* response);
    //
    //
    // Ledger/Blockchain RPC API
    // This section will be outlining the ledger/blockchain
    // specific requests.
    //
    // GetBestBlockHash - get the current chain tip hash
    // GetBestBlockHeight - get the current chain tip height
    // GetBlockHash(height uint64) - get the specified block hash
    // GetBlockHeader(hash string) - get the header for the specified block hash
    // GetBlock(hash string) - get the block with the specified hash
    // GetBlockInfo(hash string) - get the block metadata for the specified block hash
    //
    //
    virtual ::grpc::Status GetBestBlockHash(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHashResponse* response);
    virtual ::grpc::Status GetBestBlockHeight(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHeightResponse* response);
    virtual ::grpc::Status GetBlockHash(::grpc::ServerContext* context, const ::ledger::GetBlockHashRequest* request, ::ledger::GetBlockHashResponse* response);
    virtual ::grpc::Status GetBlockHeader(::grpc::ServerContext* context, const ::ledger::GetBlockHeaderRequest* request, ::ledger::GetBlockHeaderResponse* response);
    virtual ::grpc::Status GetBlock(::grpc::ServerContext* context, const ::ledger::GetBlockRequest* request, ::ledger::GetBlockResponse* response);
    virtual ::grpc::Status GetBlockInfo(::grpc::ServerContext* context, const ::ledger::GetBlockInfoRequest* request, ::ledger::GetBlockInfoResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_IsTestnet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_IsTestnet() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_IsTestnet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsTestnet(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::IsTestnetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsTestnet(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::ledger::IsTestnetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNetworkName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetNetworkName() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetNetworkName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetNetworkNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetworkName(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetNetworkNameResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetVersion() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSubversion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetSubversion() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetSubversion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubversion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetSubversionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSubversion(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetSubversionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCoinName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetCoinName() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetCoinName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCoinName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetCoinNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCoinName(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetCoinNameResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetChainInfo() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetChainInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChainInfo(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetChainInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBestBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetBestBlockHash() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetBestBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBestBlockHash(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBestBlockHash(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetBestBlockHashResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBestBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetBestBlockHeight() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetBestBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBestBlockHeight(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHeightResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBestBlockHeight(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetBestBlockHeightResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetBlockHash() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* context, const ::ledger::GetBlockHashRequest* request, ::ledger::GetBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHash(::grpc::ServerContext* context, ::ledger::GetBlockHashRequest* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetBlockHashResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetBlockHeader() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* context, const ::ledger::GetBlockHeaderRequest* request, ::ledger::GetBlockHeaderResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeader(::grpc::ServerContext* context, ::ledger::GetBlockHeaderRequest* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetBlockHeaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetBlock() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* context, const ::ledger::GetBlockRequest* request, ::ledger::GetBlockResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlock(::grpc::ServerContext* context, ::ledger::GetBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetBlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetBlockInfo() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetBlockInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockInfo(::grpc::ServerContext* context, const ::ledger::GetBlockInfoRequest* request, ::ledger::GetBlockInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockInfo(::grpc::ServerContext* context, ::ledger::GetBlockInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::ledger::GetBlockInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_IsTestnet<WithAsyncMethod_GetNetworkName<WithAsyncMethod_GetVersion<WithAsyncMethod_GetSubversion<WithAsyncMethod_GetCoinName<WithAsyncMethod_GetChainInfo<WithAsyncMethod_GetBestBlockHash<WithAsyncMethod_GetBestBlockHeight<WithAsyncMethod_GetBlockHash<WithAsyncMethod_GetBlockHeader<WithAsyncMethod_GetBlock<WithAsyncMethod_GetBlockInfo<Service > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_IsTestnet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_IsTestnet() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::ledger::IsTestnetResponse>(
          [this](::grpc::ServerContext* context,
                 const ::google::protobuf::Empty* request,
                 ::ledger::IsTestnetResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->IsTestnet(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_IsTestnet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsTestnet(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::IsTestnetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void IsTestnet(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::IsTestnetResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNetworkName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetNetworkName() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::ledger::GetNetworkNameResponse>(
          [this](::grpc::ServerContext* context,
                 const ::google::protobuf::Empty* request,
                 ::ledger::GetNetworkNameResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetNetworkName(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetNetworkName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetNetworkNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetNetworkName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetNetworkNameResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetVersion() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::ledger::GetVersionResponse>(
          [this](::grpc::ServerContext* context,
                 const ::google::protobuf::Empty* request,
                 ::ledger::GetVersionResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetVersion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetVersion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetVersionResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSubversion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetSubversion() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::ledger::GetSubversionResponse>(
          [this](::grpc::ServerContext* context,
                 const ::google::protobuf::Empty* request,
                 ::ledger::GetSubversionResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetSubversion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetSubversion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubversion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetSubversionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSubversion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetSubversionResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCoinName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetCoinName() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::ledger::GetCoinNameResponse>(
          [this](::grpc::ServerContext* context,
                 const ::google::protobuf::Empty* request,
                 ::ledger::GetCoinNameResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetCoinName(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetCoinName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCoinName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetCoinNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCoinName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetCoinNameResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetChainInfo() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::ledger::GetChainInfoResponse>(
          [this](::grpc::ServerContext* context,
                 const ::google::protobuf::Empty* request,
                 ::ledger::GetChainInfoResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetChainInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetChainInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetChainInfo(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetChainInfoResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBestBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetBestBlockHash() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::ledger::GetBestBlockHashResponse>(
          [this](::grpc::ServerContext* context,
                 const ::google::protobuf::Empty* request,
                 ::ledger::GetBestBlockHashResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetBestBlockHash(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetBestBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBestBlockHash(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBestBlockHash(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHashResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBestBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetBestBlockHeight() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::ledger::GetBestBlockHeightResponse>(
          [this](::grpc::ServerContext* context,
                 const ::google::protobuf::Empty* request,
                 ::ledger::GetBestBlockHeightResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetBestBlockHeight(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetBestBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBestBlockHeight(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHeightResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBestBlockHeight(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHeightResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockHash() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::ledger::GetBlockHashRequest, ::ledger::GetBlockHashResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ledger::GetBlockHashRequest* request,
                 ::ledger::GetBlockHashResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetBlockHash(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* context, const ::ledger::GetBlockHashRequest* request, ::ledger::GetBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBlockHash(::grpc::ServerContext* context, const ::ledger::GetBlockHashRequest* request, ::ledger::GetBlockHashResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockHeader() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::ledger::GetBlockHeaderRequest, ::ledger::GetBlockHeaderResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ledger::GetBlockHeaderRequest* request,
                 ::ledger::GetBlockHeaderResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetBlockHeader(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* context, const ::ledger::GetBlockHeaderRequest* request, ::ledger::GetBlockHeaderResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBlockHeader(::grpc::ServerContext* context, const ::ledger::GetBlockHeaderRequest* request, ::ledger::GetBlockHeaderResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetBlock() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::ledger::GetBlockRequest, ::ledger::GetBlockResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ledger::GetBlockRequest* request,
                 ::ledger::GetBlockResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetBlock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* context, const ::ledger::GetBlockRequest* request, ::ledger::GetBlockResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBlock(::grpc::ServerContext* context, const ::ledger::GetBlockRequest* request, ::ledger::GetBlockResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockInfo() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::ledger::GetBlockInfoRequest, ::ledger::GetBlockInfoResponse>(
          [this](::grpc::ServerContext* context,
                 const ::ledger::GetBlockInfoRequest* request,
                 ::ledger::GetBlockInfoResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetBlockInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_GetBlockInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockInfo(::grpc::ServerContext* context, const ::ledger::GetBlockInfoRequest* request, ::ledger::GetBlockInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBlockInfo(::grpc::ServerContext* context, const ::ledger::GetBlockInfoRequest* request, ::ledger::GetBlockInfoResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_IsTestnet<ExperimentalWithCallbackMethod_GetNetworkName<ExperimentalWithCallbackMethod_GetVersion<ExperimentalWithCallbackMethod_GetSubversion<ExperimentalWithCallbackMethod_GetCoinName<ExperimentalWithCallbackMethod_GetChainInfo<ExperimentalWithCallbackMethod_GetBestBlockHash<ExperimentalWithCallbackMethod_GetBestBlockHeight<ExperimentalWithCallbackMethod_GetBlockHash<ExperimentalWithCallbackMethod_GetBlockHeader<ExperimentalWithCallbackMethod_GetBlock<ExperimentalWithCallbackMethod_GetBlockInfo<Service > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_IsTestnet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_IsTestnet() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_IsTestnet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsTestnet(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::IsTestnetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNetworkName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetNetworkName() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetNetworkName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetNetworkNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetVersion() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSubversion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetSubversion() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetSubversion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubversion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetSubversionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCoinName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetCoinName() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetCoinName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCoinName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetCoinNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetChainInfo() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetChainInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBestBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetBestBlockHash() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetBestBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBestBlockHash(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBestBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetBestBlockHeight() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetBestBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBestBlockHeight(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHeightResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetBlockHash() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* context, const ::ledger::GetBlockHashRequest* request, ::ledger::GetBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetBlockHeader() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* context, const ::ledger::GetBlockHeaderRequest* request, ::ledger::GetBlockHeaderResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetBlock() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* context, const ::ledger::GetBlockRequest* request, ::ledger::GetBlockResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetBlockInfo() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetBlockInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockInfo(::grpc::ServerContext* context, const ::ledger::GetBlockInfoRequest* request, ::ledger::GetBlockInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsTestnet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_IsTestnet() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_IsTestnet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsTestnet(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::IsTestnetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsTestnet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNetworkName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetNetworkName() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetNetworkName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetNetworkNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetworkName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetVersion() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSubversion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetSubversion() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetSubversion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubversion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetSubversionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSubversion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCoinName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetCoinName() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetCoinName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCoinName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetCoinNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCoinName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetChainInfo() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetChainInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChainInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBestBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetBestBlockHash() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetBestBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBestBlockHash(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBestBlockHash(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBestBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetBestBlockHeight() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetBestBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBestBlockHeight(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHeightResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBestBlockHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetBlockHash() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* context, const ::ledger::GetBlockHashRequest* request, ::ledger::GetBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHash(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetBlockHeader() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* context, const ::ledger::GetBlockHeaderRequest* request, ::ledger::GetBlockHeaderResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeader(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetBlock() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* context, const ::ledger::GetBlockRequest* request, ::ledger::GetBlockResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetBlockInfo() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetBlockInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockInfo(::grpc::ServerContext* context, const ::ledger::GetBlockInfoRequest* request, ::ledger::GetBlockInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_IsTestnet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_IsTestnet() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->IsTestnet(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_IsTestnet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsTestnet(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::IsTestnetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void IsTestnet(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNetworkName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNetworkName() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetNetworkName(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNetworkName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetNetworkNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetNetworkName(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVersion() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetVersion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetVersion(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSubversion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSubversion() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetSubversion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSubversion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubversion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetSubversionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetSubversion(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCoinName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCoinName() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetCoinName(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCoinName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCoinName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetCoinNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetCoinName(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetChainInfo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetChainInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetChainInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetChainInfo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBestBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBestBlockHash() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetBestBlockHash(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBestBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBestBlockHash(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBestBlockHash(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBestBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBestBlockHeight() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetBestBlockHeight(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBestBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBestBlockHeight(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHeightResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBestBlockHeight(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockHash() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetBlockHash(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* context, const ::ledger::GetBlockHashRequest* request, ::ledger::GetBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBlockHash(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockHeader() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetBlockHeader(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* context, const ::ledger::GetBlockHeaderRequest* request, ::ledger::GetBlockHeaderResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBlockHeader(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlock() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetBlock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* context, const ::ledger::GetBlockRequest* request, ::ledger::GetBlockResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBlock(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockInfo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetBlockInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockInfo(::grpc::ServerContext* context, const ::ledger::GetBlockInfoRequest* request, ::ledger::GetBlockInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetBlockInfo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsTestnet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_IsTestnet() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::google::protobuf::Empty, ::ledger::IsTestnetResponse>(std::bind(&WithStreamedUnaryMethod_IsTestnet<BaseClass>::StreamedIsTestnet, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_IsTestnet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsTestnet(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::IsTestnetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsTestnet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::ledger::IsTestnetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNetworkName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetNetworkName() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::google::protobuf::Empty, ::ledger::GetNetworkNameResponse>(std::bind(&WithStreamedUnaryMethod_GetNetworkName<BaseClass>::StreamedGetNetworkName, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetNetworkName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNetworkName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetNetworkNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNetworkName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::ledger::GetNetworkNameResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetVersion() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::google::protobuf::Empty, ::ledger::GetVersionResponse>(std::bind(&WithStreamedUnaryMethod_GetVersion<BaseClass>::StreamedGetVersion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::ledger::GetVersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSubversion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetSubversion() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::google::protobuf::Empty, ::ledger::GetSubversionResponse>(std::bind(&WithStreamedUnaryMethod_GetSubversion<BaseClass>::StreamedGetSubversion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetSubversion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSubversion(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetSubversionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSubversion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::ledger::GetSubversionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCoinName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetCoinName() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::google::protobuf::Empty, ::ledger::GetCoinNameResponse>(std::bind(&WithStreamedUnaryMethod_GetCoinName<BaseClass>::StreamedGetCoinName, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetCoinName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCoinName(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetCoinNameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCoinName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::ledger::GetCoinNameResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetChainInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetChainInfo() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::google::protobuf::Empty, ::ledger::GetChainInfoResponse>(std::bind(&WithStreamedUnaryMethod_GetChainInfo<BaseClass>::StreamedGetChainInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetChainInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetChainInfo(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetChainInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetChainInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::ledger::GetChainInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBestBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetBestBlockHash() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::google::protobuf::Empty, ::ledger::GetBestBlockHashResponse>(std::bind(&WithStreamedUnaryMethod_GetBestBlockHash<BaseClass>::StreamedGetBestBlockHash, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBestBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBestBlockHash(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBestBlockHash(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::ledger::GetBestBlockHashResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBestBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetBestBlockHeight() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::google::protobuf::Empty, ::ledger::GetBestBlockHeightResponse>(std::bind(&WithStreamedUnaryMethod_GetBestBlockHeight<BaseClass>::StreamedGetBestBlockHeight, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBestBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBestBlockHeight(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::ledger::GetBestBlockHeightResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBestBlockHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::ledger::GetBestBlockHeightResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetBlockHash() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::ledger::GetBlockHashRequest, ::ledger::GetBlockHashResponse>(std::bind(&WithStreamedUnaryMethod_GetBlockHash<BaseClass>::StreamedGetBlockHash, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBlockHash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHash(::grpc::ServerContext* context, const ::ledger::GetBlockHashRequest* request, ::ledger::GetBlockHashResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHash(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ledger::GetBlockHashRequest,::ledger::GetBlockHashResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetBlockHeader() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::ledger::GetBlockHeaderRequest, ::ledger::GetBlockHeaderResponse>(std::bind(&WithStreamedUnaryMethod_GetBlockHeader<BaseClass>::StreamedGetBlockHeader, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHeader(::grpc::ServerContext* context, const ::ledger::GetBlockHeaderRequest* request, ::ledger::GetBlockHeaderResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHeader(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ledger::GetBlockHeaderRequest,::ledger::GetBlockHeaderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetBlock() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::ledger::GetBlockRequest, ::ledger::GetBlockResponse>(std::bind(&WithStreamedUnaryMethod_GetBlock<BaseClass>::StreamedGetBlock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlock(::grpc::ServerContext* context, const ::ledger::GetBlockRequest* request, ::ledger::GetBlockResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ledger::GetBlockRequest,::ledger::GetBlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetBlockInfo() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::ledger::GetBlockInfoRequest, ::ledger::GetBlockInfoResponse>(std::bind(&WithStreamedUnaryMethod_GetBlockInfo<BaseClass>::StreamedGetBlockInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetBlockInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockInfo(::grpc::ServerContext* context, const ::ledger::GetBlockInfoRequest* request, ::ledger::GetBlockInfoResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ledger::GetBlockInfoRequest,::ledger::GetBlockInfoResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_IsTestnet<WithStreamedUnaryMethod_GetNetworkName<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_GetSubversion<WithStreamedUnaryMethod_GetCoinName<WithStreamedUnaryMethod_GetChainInfo<WithStreamedUnaryMethod_GetBestBlockHash<WithStreamedUnaryMethod_GetBestBlockHeight<WithStreamedUnaryMethod_GetBlockHash<WithStreamedUnaryMethod_GetBlockHeader<WithStreamedUnaryMethod_GetBlock<WithStreamedUnaryMethod_GetBlockInfo<Service > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_IsTestnet<WithStreamedUnaryMethod_GetNetworkName<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_GetSubversion<WithStreamedUnaryMethod_GetCoinName<WithStreamedUnaryMethod_GetChainInfo<WithStreamedUnaryMethod_GetBestBlockHash<WithStreamedUnaryMethod_GetBestBlockHeight<WithStreamedUnaryMethod_GetBlockHash<WithStreamedUnaryMethod_GetBlockHeader<WithStreamedUnaryMethod_GetBlock<WithStreamedUnaryMethod_GetBlockInfo<Service > > > > > > > > > > > > StreamedService;
};
//
//
// Metadata RPC API
// This section will be outlining the metadata API for the
// ledger.
//
// IsTestnet - Used to determine whether the current ledger is
// running on a test network
// GetNetworkName - Used to get the network name
// GetSubversion - Used to fetch the current version
// GetCoinName - Used to get the cryptocurrency string symbol
// GetChainInfo - Used to fetch all the metadata
//

}  // namespace ledger


#endif  // GRPC_proto_2fledger_2eproto__INCLUDED
