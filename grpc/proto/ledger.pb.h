// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/ledger.proto

#ifndef PROTOBUF_INCLUDED_proto_2fledger_2eproto
#define PROTOBUF_INCLUDED_proto_2fledger_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/empty.pb.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_proto_2fledger_2eproto 

namespace protobuf_proto_2fledger_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[21];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_proto_2fledger_2eproto
namespace ledger {
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class BlockHeader;
class BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class BlockInfo;
class BlockInfoDefaultTypeInternal;
extern BlockInfoDefaultTypeInternal _BlockInfo_default_instance_;
class ChainInfo;
class ChainInfoDefaultTypeInternal;
extern ChainInfoDefaultTypeInternal _ChainInfo_default_instance_;
class GetBestBlockHashResponse;
class GetBestBlockHashResponseDefaultTypeInternal;
extern GetBestBlockHashResponseDefaultTypeInternal _GetBestBlockHashResponse_default_instance_;
class GetBestBlockHeightResponse;
class GetBestBlockHeightResponseDefaultTypeInternal;
extern GetBestBlockHeightResponseDefaultTypeInternal _GetBestBlockHeightResponse_default_instance_;
class GetBlockHashRequest;
class GetBlockHashRequestDefaultTypeInternal;
extern GetBlockHashRequestDefaultTypeInternal _GetBlockHashRequest_default_instance_;
class GetBlockHashResponse;
class GetBlockHashResponseDefaultTypeInternal;
extern GetBlockHashResponseDefaultTypeInternal _GetBlockHashResponse_default_instance_;
class GetBlockHeaderRequest;
class GetBlockHeaderRequestDefaultTypeInternal;
extern GetBlockHeaderRequestDefaultTypeInternal _GetBlockHeaderRequest_default_instance_;
class GetBlockHeaderResponse;
class GetBlockHeaderResponseDefaultTypeInternal;
extern GetBlockHeaderResponseDefaultTypeInternal _GetBlockHeaderResponse_default_instance_;
class GetBlockInfoRequest;
class GetBlockInfoRequestDefaultTypeInternal;
extern GetBlockInfoRequestDefaultTypeInternal _GetBlockInfoRequest_default_instance_;
class GetBlockInfoResponse;
class GetBlockInfoResponseDefaultTypeInternal;
extern GetBlockInfoResponseDefaultTypeInternal _GetBlockInfoResponse_default_instance_;
class GetBlockRequest;
class GetBlockRequestDefaultTypeInternal;
extern GetBlockRequestDefaultTypeInternal _GetBlockRequest_default_instance_;
class GetBlockResponse;
class GetBlockResponseDefaultTypeInternal;
extern GetBlockResponseDefaultTypeInternal _GetBlockResponse_default_instance_;
class GetChainInfoResponse;
class GetChainInfoResponseDefaultTypeInternal;
extern GetChainInfoResponseDefaultTypeInternal _GetChainInfoResponse_default_instance_;
class GetCoinNameResponse;
class GetCoinNameResponseDefaultTypeInternal;
extern GetCoinNameResponseDefaultTypeInternal _GetCoinNameResponse_default_instance_;
class GetNetworkNameResponse;
class GetNetworkNameResponseDefaultTypeInternal;
extern GetNetworkNameResponseDefaultTypeInternal _GetNetworkNameResponse_default_instance_;
class GetSubversionResponse;
class GetSubversionResponseDefaultTypeInternal;
extern GetSubversionResponseDefaultTypeInternal _GetSubversionResponse_default_instance_;
class GetVersionResponse;
class GetVersionResponseDefaultTypeInternal;
extern GetVersionResponseDefaultTypeInternal _GetVersionResponse_default_instance_;
class IsTestnetResponse;
class IsTestnetResponseDefaultTypeInternal;
extern IsTestnetResponseDefaultTypeInternal _IsTestnetResponse_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
}  // namespace ledger
namespace google {
namespace protobuf {
template<> ::ledger::Block* Arena::CreateMaybeMessage<::ledger::Block>(Arena*);
template<> ::ledger::BlockHeader* Arena::CreateMaybeMessage<::ledger::BlockHeader>(Arena*);
template<> ::ledger::BlockInfo* Arena::CreateMaybeMessage<::ledger::BlockInfo>(Arena*);
template<> ::ledger::ChainInfo* Arena::CreateMaybeMessage<::ledger::ChainInfo>(Arena*);
template<> ::ledger::GetBestBlockHashResponse* Arena::CreateMaybeMessage<::ledger::GetBestBlockHashResponse>(Arena*);
template<> ::ledger::GetBestBlockHeightResponse* Arena::CreateMaybeMessage<::ledger::GetBestBlockHeightResponse>(Arena*);
template<> ::ledger::GetBlockHashRequest* Arena::CreateMaybeMessage<::ledger::GetBlockHashRequest>(Arena*);
template<> ::ledger::GetBlockHashResponse* Arena::CreateMaybeMessage<::ledger::GetBlockHashResponse>(Arena*);
template<> ::ledger::GetBlockHeaderRequest* Arena::CreateMaybeMessage<::ledger::GetBlockHeaderRequest>(Arena*);
template<> ::ledger::GetBlockHeaderResponse* Arena::CreateMaybeMessage<::ledger::GetBlockHeaderResponse>(Arena*);
template<> ::ledger::GetBlockInfoRequest* Arena::CreateMaybeMessage<::ledger::GetBlockInfoRequest>(Arena*);
template<> ::ledger::GetBlockInfoResponse* Arena::CreateMaybeMessage<::ledger::GetBlockInfoResponse>(Arena*);
template<> ::ledger::GetBlockRequest* Arena::CreateMaybeMessage<::ledger::GetBlockRequest>(Arena*);
template<> ::ledger::GetBlockResponse* Arena::CreateMaybeMessage<::ledger::GetBlockResponse>(Arena*);
template<> ::ledger::GetChainInfoResponse* Arena::CreateMaybeMessage<::ledger::GetChainInfoResponse>(Arena*);
template<> ::ledger::GetCoinNameResponse* Arena::CreateMaybeMessage<::ledger::GetCoinNameResponse>(Arena*);
template<> ::ledger::GetNetworkNameResponse* Arena::CreateMaybeMessage<::ledger::GetNetworkNameResponse>(Arena*);
template<> ::ledger::GetSubversionResponse* Arena::CreateMaybeMessage<::ledger::GetSubversionResponse>(Arena*);
template<> ::ledger::GetVersionResponse* Arena::CreateMaybeMessage<::ledger::GetVersionResponse>(Arena*);
template<> ::ledger::IsTestnetResponse* Arena::CreateMaybeMessage<::ledger::IsTestnetResponse>(Arena*);
template<> ::ledger::Transaction* Arena::CreateMaybeMessage<::ledger::Transaction>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ledger {

// ===================================================================

class ChainInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.ChainInfo) */ {
 public:
  ChainInfo();
  virtual ~ChainInfo();

  ChainInfo(const ChainInfo& from);

  inline ChainInfo& operator=(const ChainInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChainInfo(ChainInfo&& from) noexcept
    : ChainInfo() {
    *this = ::std::move(from);
  }

  inline ChainInfo& operator=(ChainInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChainInfo* internal_default_instance() {
    return reinterpret_cast<const ChainInfo*>(
               &_ChainInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ChainInfo* other);
  friend void swap(ChainInfo& a, ChainInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChainInfo* New() const final {
    return CreateMaybeMessage<ChainInfo>(NULL);
  }

  ChainInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChainInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChainInfo& from);
  void MergeFrom(const ChainInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chain_name = 1;
  void clear_chain_name();
  static const int kChainNameFieldNumber = 1;
  const ::std::string& chain_name() const;
  void set_chain_name(const ::std::string& value);
  #if LANG_CXX11
  void set_chain_name(::std::string&& value);
  #endif
  void set_chain_name(const char* value);
  void set_chain_name(const char* value, size_t size);
  ::std::string* mutable_chain_name();
  ::std::string* release_chain_name();
  void set_allocated_chain_name(::std::string* chain_name);

  // string block_hash = 4;
  void clear_block_hash();
  static const int kBlockHashFieldNumber = 4;
  const ::std::string& block_hash() const;
  void set_block_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_block_hash(::std::string&& value);
  #endif
  void set_block_hash(const char* value);
  void set_block_hash(const char* value, size_t size);
  ::std::string* mutable_block_hash();
  ::std::string* release_block_hash();
  void set_allocated_block_hash(::std::string* block_hash);

  // string difficulty = 5;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 5;
  const ::std::string& difficulty() const;
  void set_difficulty(const ::std::string& value);
  #if LANG_CXX11
  void set_difficulty(::std::string&& value);
  #endif
  void set_difficulty(const char* value);
  void set_difficulty(const char* value, size_t size);
  ::std::string* mutable_difficulty();
  ::std::string* release_difficulty();
  void set_allocated_difficulty(::std::string* difficulty);

  // string version = 6;
  void clear_version();
  static const int kVersionFieldNumber = 6;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string sub_version = 7;
  void clear_sub_version();
  static const int kSubVersionFieldNumber = 7;
  const ::std::string& sub_version() const;
  void set_sub_version(const ::std::string& value);
  #if LANG_CXX11
  void set_sub_version(::std::string&& value);
  #endif
  void set_sub_version(const char* value);
  void set_sub_version(const char* value, size_t size);
  ::std::string* mutable_sub_version();
  ::std::string* release_sub_version();
  void set_allocated_sub_version(::std::string* sub_version);

  // string protocol_version = 8;
  void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 8;
  const ::std::string& protocol_version() const;
  void set_protocol_version(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol_version(::std::string&& value);
  #endif
  void set_protocol_version(const char* value);
  void set_protocol_version(const char* value, size_t size);
  ::std::string* mutable_protocol_version();
  ::std::string* release_protocol_version();
  void set_allocated_protocol_version(::std::string* protocol_version);

  // uint64 num_blocks = 2;
  void clear_num_blocks();
  static const int kNumBlocksFieldNumber = 2;
  ::google::protobuf::uint64 num_blocks() const;
  void set_num_blocks(::google::protobuf::uint64 value);

  // uint64 num_headers = 3;
  void clear_num_headers();
  static const int kNumHeadersFieldNumber = 3;
  ::google::protobuf::uint64 num_headers() const;
  void set_num_headers(::google::protobuf::uint64 value);

  // int32 decimals = 9;
  void clear_decimals();
  static const int kDecimalsFieldNumber = 9;
  ::google::protobuf::int32 decimals() const;
  void set_decimals(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ledger.ChainInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chain_name_;
  ::google::protobuf::internal::ArenaStringPtr block_hash_;
  ::google::protobuf::internal::ArenaStringPtr difficulty_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr sub_version_;
  ::google::protobuf::internal::ArenaStringPtr protocol_version_;
  ::google::protobuf::uint64 num_blocks_;
  ::google::protobuf::uint64 num_headers_;
  ::google::protobuf::int32 decimals_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.BlockHeader) */ {
 public:
  BlockHeader();
  virtual ~BlockHeader();

  BlockHeader(const BlockHeader& from);

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BlockHeader* other);
  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader* New() const final {
    return CreateMaybeMessage<BlockHeader>(NULL);
  }

  BlockHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockHeader& from);
  void MergeFrom(const BlockHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .google.protobuf.Timestamp time_stamp = 8;
  bool has_time_stamp() const;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 8;
  private:
  const ::google::protobuf::Timestamp& _internal_time_stamp() const;
  public:
  const ::google::protobuf::Timestamp& time_stamp() const;
  ::google::protobuf::Timestamp* release_time_stamp();
  ::google::protobuf::Timestamp* mutable_time_stamp();
  void set_allocated_time_stamp(::google::protobuf::Timestamp* time_stamp);

  // uint64 height = 5;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // uint64 confirmations = 6;
  void clear_confirmations();
  static const int kConfirmationsFieldNumber = 6;
  ::google::protobuf::uint64 confirmations() const;
  void set_confirmations(::google::protobuf::uint64 value);

  // uint64 size = 7;
  void clear_size();
  static const int kSizeFieldNumber = 7;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ledger.BlockHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::Timestamp* time_stamp_;
  ::google::protobuf::uint64 height_;
  ::google::protobuf::uint64 confirmations_;
  ::google::protobuf::uint64 size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(NULL);
  }

  Transaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // string to = 2;
  void clear_to();
  static const int kToFieldNumber = 2;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // string amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // .google.protobuf.Timestamp time_stamp = 5;
  bool has_time_stamp() const;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 5;
  private:
  const ::google::protobuf::Timestamp& _internal_time_stamp() const;
  public:
  const ::google::protobuf::Timestamp& time_stamp() const;
  ::google::protobuf::Timestamp* release_time_stamp();
  ::google::protobuf::Timestamp* mutable_time_stamp();
  void set_allocated_time_stamp(::google::protobuf::Timestamp* time_stamp);

  // uint64 nonce = 4;
  void clear_nonce();
  static const int kNonceFieldNumber = 4;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ledger.Transaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  ::google::protobuf::Timestamp* time_stamp_;
  ::google::protobuf::uint64 nonce_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Block* other);
  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(NULL);
  }

  Block* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string past = 3;
  int past_size() const;
  void clear_past();
  static const int kPastFieldNumber = 3;
  const ::std::string& past(int index) const;
  ::std::string* mutable_past(int index);
  void set_past(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_past(int index, ::std::string&& value);
  #endif
  void set_past(int index, const char* value);
  void set_past(int index, const char* value, size_t size);
  ::std::string* add_past();
  void add_past(const ::std::string& value);
  #if LANG_CXX11
  void add_past(::std::string&& value);
  #endif
  void add_past(const char* value);
  void add_past(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& past() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_past();

  // repeated string future = 4;
  int future_size() const;
  void clear_future();
  static const int kFutureFieldNumber = 4;
  const ::std::string& future(int index) const;
  ::std::string* mutable_future(int index);
  void set_future(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_future(int index, ::std::string&& value);
  #endif
  void set_future(int index, const char* value);
  void set_future(int index, const char* value, size_t size);
  ::std::string* add_future();
  void add_future(const ::std::string& value);
  #if LANG_CXX11
  void add_future(::std::string&& value);
  #endif
  void add_future(const char* value);
  void add_future(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& future() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_future();

  // repeated string anticone = 5;
  int anticone_size() const;
  void clear_anticone();
  static const int kAnticoneFieldNumber = 5;
  const ::std::string& anticone(int index) const;
  ::std::string* mutable_anticone(int index);
  void set_anticone(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_anticone(int index, ::std::string&& value);
  #endif
  void set_anticone(int index, const char* value);
  void set_anticone(int index, const char* value, size_t size);
  ::std::string* add_anticone();
  void add_anticone(const ::std::string& value);
  #if LANG_CXX11
  void add_anticone(::std::string&& value);
  #endif
  void add_anticone(const char* value);
  void add_anticone(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& anticone() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_anticone();

  // repeated string tips = 6;
  int tips_size() const;
  void clear_tips();
  static const int kTipsFieldNumber = 6;
  const ::std::string& tips(int index) const;
  ::std::string* mutable_tips(int index);
  void set_tips(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tips(int index, ::std::string&& value);
  #endif
  void set_tips(int index, const char* value);
  void set_tips(int index, const char* value, size_t size);
  ::std::string* add_tips();
  void add_tips(const ::std::string& value);
  #if LANG_CXX11
  void add_tips(::std::string&& value);
  #endif
  void add_tips(const char* value);
  void add_tips(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tips() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tips();

  // repeated .ledger.Transaction transactions = 7;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 7;
  ::ledger::Transaction* mutable_transactions(int index);
  ::google::protobuf::RepeatedPtrField< ::ledger::Transaction >*
      mutable_transactions();
  const ::ledger::Transaction& transactions(int index) const;
  ::ledger::Transaction* add_transactions();
  const ::google::protobuf::RepeatedPtrField< ::ledger::Transaction >&
      transactions() const;

  // string pivot = 2;
  void clear_pivot();
  static const int kPivotFieldNumber = 2;
  const ::std::string& pivot() const;
  void set_pivot(const ::std::string& value);
  #if LANG_CXX11
  void set_pivot(::std::string&& value);
  #endif
  void set_pivot(const char* value);
  void set_pivot(const char* value, size_t size);
  ::std::string* mutable_pivot();
  ::std::string* release_pivot();
  void set_allocated_pivot(::std::string* pivot);

  // bytes signature = 8;
  void clear_signature();
  static const int kSignatureFieldNumber = 8;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // string hash = 9;
  void clear_hash();
  static const int kHashFieldNumber = 9;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string publisher = 10;
  void clear_publisher();
  static const int kPublisherFieldNumber = 10;
  const ::std::string& publisher() const;
  void set_publisher(const ::std::string& value);
  #if LANG_CXX11
  void set_publisher(::std::string&& value);
  #endif
  void set_publisher(const char* value);
  void set_publisher(const char* value, size_t size);
  ::std::string* mutable_publisher();
  ::std::string* release_publisher();
  void set_allocated_publisher(::std::string* publisher);

  // .ledger.BlockHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::ledger::BlockHeader& _internal_header() const;
  public:
  const ::ledger::BlockHeader& header() const;
  ::ledger::BlockHeader* release_header();
  ::ledger::BlockHeader* mutable_header();
  void set_allocated_header(::ledger::BlockHeader* header);

  // @@protoc_insertion_point(class_scope:ledger.Block)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> past_;
  ::google::protobuf::RepeatedPtrField< ::std::string> future_;
  ::google::protobuf::RepeatedPtrField< ::std::string> anticone_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tips_;
  ::google::protobuf::RepeatedPtrField< ::ledger::Transaction > transactions_;
  ::google::protobuf::internal::ArenaStringPtr pivot_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr publisher_;
  ::ledger::BlockHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.BlockInfo) */ {
 public:
  BlockInfo();
  virtual ~BlockInfo();

  BlockInfo(const BlockInfo& from);

  inline BlockInfo& operator=(const BlockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockInfo(BlockInfo&& from) noexcept
    : BlockInfo() {
    *this = ::std::move(from);
  }

  inline BlockInfo& operator=(BlockInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockInfo* internal_default_instance() {
    return reinterpret_cast<const BlockInfo*>(
               &_BlockInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BlockInfo* other);
  friend void swap(BlockInfo& a, BlockInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockInfo* New() const final {
    return CreateMaybeMessage<BlockInfo>(NULL);
  }

  BlockInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockInfo& from);
  void MergeFrom(const BlockInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string transaction_ids = 6;
  int transaction_ids_size() const;
  void clear_transaction_ids();
  static const int kTransactionIdsFieldNumber = 6;
  const ::std::string& transaction_ids(int index) const;
  ::std::string* mutable_transaction_ids(int index);
  void set_transaction_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_transaction_ids(int index, ::std::string&& value);
  #endif
  void set_transaction_ids(int index, const char* value);
  void set_transaction_ids(int index, const char* value, size_t size);
  ::std::string* add_transaction_ids();
  void add_transaction_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_transaction_ids(::std::string&& value);
  #endif
  void add_transaction_ids(const char* value);
  void add_transaction_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& transaction_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_transaction_ids();

  // string merkle_root = 2;
  void clear_merkle_root();
  static const int kMerkleRootFieldNumber = 2;
  const ::std::string& merkle_root() const;
  void set_merkle_root(const ::std::string& value);
  #if LANG_CXX11
  void set_merkle_root(::std::string&& value);
  #endif
  void set_merkle_root(const char* value);
  void set_merkle_root(const char* value, size_t size);
  ::std::string* mutable_merkle_root();
  ::std::string* release_merkle_root();
  void set_allocated_merkle_root(::std::string* merkle_root);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string difficulty = 5;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 5;
  const ::std::string& difficulty() const;
  void set_difficulty(const ::std::string& value);
  #if LANG_CXX11
  void set_difficulty(::std::string&& value);
  #endif
  void set_difficulty(const char* value);
  void set_difficulty(const char* value, size_t size);
  ::std::string* mutable_difficulty();
  ::std::string* release_difficulty();
  void set_allocated_difficulty(::std::string* difficulty);

  // .ledger.BlockHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::ledger::BlockHeader& _internal_header() const;
  public:
  const ::ledger::BlockHeader& header() const;
  ::ledger::BlockHeader* release_header();
  ::ledger::BlockHeader* mutable_header();
  void set_allocated_header(::ledger::BlockHeader* header);

  // uint64 nonce = 4;
  void clear_nonce();
  static const int kNonceFieldNumber = 4;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ledger.BlockInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> transaction_ids_;
  ::google::protobuf::internal::ArenaStringPtr merkle_root_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr difficulty_;
  ::ledger::BlockHeader* header_;
  ::google::protobuf::uint64 nonce_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsTestnetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.IsTestnetResponse) */ {
 public:
  IsTestnetResponse();
  virtual ~IsTestnetResponse();

  IsTestnetResponse(const IsTestnetResponse& from);

  inline IsTestnetResponse& operator=(const IsTestnetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsTestnetResponse(IsTestnetResponse&& from) noexcept
    : IsTestnetResponse() {
    *this = ::std::move(from);
  }

  inline IsTestnetResponse& operator=(IsTestnetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsTestnetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsTestnetResponse* internal_default_instance() {
    return reinterpret_cast<const IsTestnetResponse*>(
               &_IsTestnetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(IsTestnetResponse* other);
  friend void swap(IsTestnetResponse& a, IsTestnetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsTestnetResponse* New() const final {
    return CreateMaybeMessage<IsTestnetResponse>(NULL);
  }

  IsTestnetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsTestnetResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsTestnetResponse& from);
  void MergeFrom(const IsTestnetResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsTestnetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_testnet = 1;
  void clear_is_testnet();
  static const int kIsTestnetFieldNumber = 1;
  bool is_testnet() const;
  void set_is_testnet(bool value);

  // @@protoc_insertion_point(class_scope:ledger.IsTestnetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_testnet_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNetworkNameResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetNetworkNameResponse) */ {
 public:
  GetNetworkNameResponse();
  virtual ~GetNetworkNameResponse();

  GetNetworkNameResponse(const GetNetworkNameResponse& from);

  inline GetNetworkNameResponse& operator=(const GetNetworkNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNetworkNameResponse(GetNetworkNameResponse&& from) noexcept
    : GetNetworkNameResponse() {
    *this = ::std::move(from);
  }

  inline GetNetworkNameResponse& operator=(GetNetworkNameResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNetworkNameResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNetworkNameResponse* internal_default_instance() {
    return reinterpret_cast<const GetNetworkNameResponse*>(
               &_GetNetworkNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetNetworkNameResponse* other);
  friend void swap(GetNetworkNameResponse& a, GetNetworkNameResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNetworkNameResponse* New() const final {
    return CreateMaybeMessage<GetNetworkNameResponse>(NULL);
  }

  GetNetworkNameResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetNetworkNameResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetNetworkNameResponse& from);
  void MergeFrom(const GetNetworkNameResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNetworkNameResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string network_name = 1;
  void clear_network_name();
  static const int kNetworkNameFieldNumber = 1;
  const ::std::string& network_name() const;
  void set_network_name(const ::std::string& value);
  #if LANG_CXX11
  void set_network_name(::std::string&& value);
  #endif
  void set_network_name(const char* value);
  void set_network_name(const char* value, size_t size);
  ::std::string* mutable_network_name();
  ::std::string* release_network_name();
  void set_allocated_network_name(::std::string* network_name);

  // @@protoc_insertion_point(class_scope:ledger.GetNetworkNameResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr network_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetVersionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetVersionResponse) */ {
 public:
  GetVersionResponse();
  virtual ~GetVersionResponse();

  GetVersionResponse(const GetVersionResponse& from);

  inline GetVersionResponse& operator=(const GetVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetVersionResponse(GetVersionResponse&& from) noexcept
    : GetVersionResponse() {
    *this = ::std::move(from);
  }

  inline GetVersionResponse& operator=(GetVersionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetVersionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVersionResponse* internal_default_instance() {
    return reinterpret_cast<const GetVersionResponse*>(
               &_GetVersionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GetVersionResponse* other);
  friend void swap(GetVersionResponse& a, GetVersionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVersionResponse* New() const final {
    return CreateMaybeMessage<GetVersionResponse>(NULL);
  }

  GetVersionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetVersionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetVersionResponse& from);
  void MergeFrom(const GetVersionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVersionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:ledger.GetVersionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSubversionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetSubversionResponse) */ {
 public:
  GetSubversionResponse();
  virtual ~GetSubversionResponse();

  GetSubversionResponse(const GetSubversionResponse& from);

  inline GetSubversionResponse& operator=(const GetSubversionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSubversionResponse(GetSubversionResponse&& from) noexcept
    : GetSubversionResponse() {
    *this = ::std::move(from);
  }

  inline GetSubversionResponse& operator=(GetSubversionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubversionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSubversionResponse* internal_default_instance() {
    return reinterpret_cast<const GetSubversionResponse*>(
               &_GetSubversionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetSubversionResponse* other);
  friend void swap(GetSubversionResponse& a, GetSubversionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSubversionResponse* New() const final {
    return CreateMaybeMessage<GetSubversionResponse>(NULL);
  }

  GetSubversionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSubversionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSubversionResponse& from);
  void MergeFrom(const GetSubversionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubversionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sub_version = 1;
  void clear_sub_version();
  static const int kSubVersionFieldNumber = 1;
  const ::std::string& sub_version() const;
  void set_sub_version(const ::std::string& value);
  #if LANG_CXX11
  void set_sub_version(::std::string&& value);
  #endif
  void set_sub_version(const char* value);
  void set_sub_version(const char* value, size_t size);
  ::std::string* mutable_sub_version();
  ::std::string* release_sub_version();
  void set_allocated_sub_version(::std::string* sub_version);

  // @@protoc_insertion_point(class_scope:ledger.GetSubversionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sub_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetCoinNameResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetCoinNameResponse) */ {
 public:
  GetCoinNameResponse();
  virtual ~GetCoinNameResponse();

  GetCoinNameResponse(const GetCoinNameResponse& from);

  inline GetCoinNameResponse& operator=(const GetCoinNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetCoinNameResponse(GetCoinNameResponse&& from) noexcept
    : GetCoinNameResponse() {
    *this = ::std::move(from);
  }

  inline GetCoinNameResponse& operator=(GetCoinNameResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCoinNameResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetCoinNameResponse* internal_default_instance() {
    return reinterpret_cast<const GetCoinNameResponse*>(
               &_GetCoinNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetCoinNameResponse* other);
  friend void swap(GetCoinNameResponse& a, GetCoinNameResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetCoinNameResponse* New() const final {
    return CreateMaybeMessage<GetCoinNameResponse>(NULL);
  }

  GetCoinNameResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetCoinNameResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetCoinNameResponse& from);
  void MergeFrom(const GetCoinNameResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCoinNameResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string coin_name = 1;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 1;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // @@protoc_insertion_point(class_scope:ledger.GetCoinNameResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetChainInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetChainInfoResponse) */ {
 public:
  GetChainInfoResponse();
  virtual ~GetChainInfoResponse();

  GetChainInfoResponse(const GetChainInfoResponse& from);

  inline GetChainInfoResponse& operator=(const GetChainInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetChainInfoResponse(GetChainInfoResponse&& from) noexcept
    : GetChainInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetChainInfoResponse& operator=(GetChainInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetChainInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetChainInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetChainInfoResponse*>(
               &_GetChainInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetChainInfoResponse* other);
  friend void swap(GetChainInfoResponse& a, GetChainInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetChainInfoResponse* New() const final {
    return CreateMaybeMessage<GetChainInfoResponse>(NULL);
  }

  GetChainInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetChainInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetChainInfoResponse& from);
  void MergeFrom(const GetChainInfoResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetChainInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.ChainInfo chain_info = 1;
  bool has_chain_info() const;
  void clear_chain_info();
  static const int kChainInfoFieldNumber = 1;
  private:
  const ::ledger::ChainInfo& _internal_chain_info() const;
  public:
  const ::ledger::ChainInfo& chain_info() const;
  ::ledger::ChainInfo* release_chain_info();
  ::ledger::ChainInfo* mutable_chain_info();
  void set_allocated_chain_info(::ledger::ChainInfo* chain_info);

  // @@protoc_insertion_point(class_scope:ledger.GetChainInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::ChainInfo* chain_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBestBlockHashResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetBestBlockHashResponse) */ {
 public:
  GetBestBlockHashResponse();
  virtual ~GetBestBlockHashResponse();

  GetBestBlockHashResponse(const GetBestBlockHashResponse& from);

  inline GetBestBlockHashResponse& operator=(const GetBestBlockHashResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBestBlockHashResponse(GetBestBlockHashResponse&& from) noexcept
    : GetBestBlockHashResponse() {
    *this = ::std::move(from);
  }

  inline GetBestBlockHashResponse& operator=(GetBestBlockHashResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBestBlockHashResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBestBlockHashResponse* internal_default_instance() {
    return reinterpret_cast<const GetBestBlockHashResponse*>(
               &_GetBestBlockHashResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetBestBlockHashResponse* other);
  friend void swap(GetBestBlockHashResponse& a, GetBestBlockHashResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBestBlockHashResponse* New() const final {
    return CreateMaybeMessage<GetBestBlockHashResponse>(NULL);
  }

  GetBestBlockHashResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBestBlockHashResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBestBlockHashResponse& from);
  void MergeFrom(const GetBestBlockHashResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBestBlockHashResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string block_hash = 1;
  void clear_block_hash();
  static const int kBlockHashFieldNumber = 1;
  const ::std::string& block_hash() const;
  void set_block_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_block_hash(::std::string&& value);
  #endif
  void set_block_hash(const char* value);
  void set_block_hash(const char* value, size_t size);
  ::std::string* mutable_block_hash();
  ::std::string* release_block_hash();
  void set_allocated_block_hash(::std::string* block_hash);

  // @@protoc_insertion_point(class_scope:ledger.GetBestBlockHashResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr block_hash_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBestBlockHeightResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetBestBlockHeightResponse) */ {
 public:
  GetBestBlockHeightResponse();
  virtual ~GetBestBlockHeightResponse();

  GetBestBlockHeightResponse(const GetBestBlockHeightResponse& from);

  inline GetBestBlockHeightResponse& operator=(const GetBestBlockHeightResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBestBlockHeightResponse(GetBestBlockHeightResponse&& from) noexcept
    : GetBestBlockHeightResponse() {
    *this = ::std::move(from);
  }

  inline GetBestBlockHeightResponse& operator=(GetBestBlockHeightResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBestBlockHeightResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBestBlockHeightResponse* internal_default_instance() {
    return reinterpret_cast<const GetBestBlockHeightResponse*>(
               &_GetBestBlockHeightResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetBestBlockHeightResponse* other);
  friend void swap(GetBestBlockHeightResponse& a, GetBestBlockHeightResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBestBlockHeightResponse* New() const final {
    return CreateMaybeMessage<GetBestBlockHeightResponse>(NULL);
  }

  GetBestBlockHeightResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBestBlockHeightResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBestBlockHeightResponse& from);
  void MergeFrom(const GetBestBlockHeightResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBestBlockHeightResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 height = 1;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ledger.GetBestBlockHeightResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlockHashRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetBlockHashRequest) */ {
 public:
  GetBlockHashRequest();
  virtual ~GetBlockHashRequest();

  GetBlockHashRequest(const GetBlockHashRequest& from);

  inline GetBlockHashRequest& operator=(const GetBlockHashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockHashRequest(GetBlockHashRequest&& from) noexcept
    : GetBlockHashRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockHashRequest& operator=(GetBlockHashRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockHashRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockHashRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockHashRequest*>(
               &_GetBlockHashRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(GetBlockHashRequest* other);
  friend void swap(GetBlockHashRequest& a, GetBlockHashRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockHashRequest* New() const final {
    return CreateMaybeMessage<GetBlockHashRequest>(NULL);
  }

  GetBlockHashRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockHashRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlockHashRequest& from);
  void MergeFrom(const GetBlockHashRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHashRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 height = 1;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ledger.GetBlockHashRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlockHashResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetBlockHashResponse) */ {
 public:
  GetBlockHashResponse();
  virtual ~GetBlockHashResponse();

  GetBlockHashResponse(const GetBlockHashResponse& from);

  inline GetBlockHashResponse& operator=(const GetBlockHashResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockHashResponse(GetBlockHashResponse&& from) noexcept
    : GetBlockHashResponse() {
    *this = ::std::move(from);
  }

  inline GetBlockHashResponse& operator=(GetBlockHashResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockHashResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockHashResponse* internal_default_instance() {
    return reinterpret_cast<const GetBlockHashResponse*>(
               &_GetBlockHashResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(GetBlockHashResponse* other);
  friend void swap(GetBlockHashResponse& a, GetBlockHashResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockHashResponse* New() const final {
    return CreateMaybeMessage<GetBlockHashResponse>(NULL);
  }

  GetBlockHashResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockHashResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlockHashResponse& from);
  void MergeFrom(const GetBlockHashResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHashResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:ledger.GetBlockHashResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlockHeaderRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetBlockHeaderRequest) */ {
 public:
  GetBlockHeaderRequest();
  virtual ~GetBlockHeaderRequest();

  GetBlockHeaderRequest(const GetBlockHeaderRequest& from);

  inline GetBlockHeaderRequest& operator=(const GetBlockHeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockHeaderRequest(GetBlockHeaderRequest&& from) noexcept
    : GetBlockHeaderRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockHeaderRequest& operator=(GetBlockHeaderRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockHeaderRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockHeaderRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockHeaderRequest*>(
               &_GetBlockHeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(GetBlockHeaderRequest* other);
  friend void swap(GetBlockHeaderRequest& a, GetBlockHeaderRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockHeaderRequest* New() const final {
    return CreateMaybeMessage<GetBlockHeaderRequest>(NULL);
  }

  GetBlockHeaderRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockHeaderRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlockHeaderRequest& from);
  void MergeFrom(const GetBlockHeaderRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHeaderRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:ledger.GetBlockHeaderRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlockHeaderResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetBlockHeaderResponse) */ {
 public:
  GetBlockHeaderResponse();
  virtual ~GetBlockHeaderResponse();

  GetBlockHeaderResponse(const GetBlockHeaderResponse& from);

  inline GetBlockHeaderResponse& operator=(const GetBlockHeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockHeaderResponse(GetBlockHeaderResponse&& from) noexcept
    : GetBlockHeaderResponse() {
    *this = ::std::move(from);
  }

  inline GetBlockHeaderResponse& operator=(GetBlockHeaderResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockHeaderResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockHeaderResponse* internal_default_instance() {
    return reinterpret_cast<const GetBlockHeaderResponse*>(
               &_GetBlockHeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GetBlockHeaderResponse* other);
  friend void swap(GetBlockHeaderResponse& a, GetBlockHeaderResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockHeaderResponse* New() const final {
    return CreateMaybeMessage<GetBlockHeaderResponse>(NULL);
  }

  GetBlockHeaderResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockHeaderResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlockHeaderResponse& from);
  void MergeFrom(const GetBlockHeaderResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHeaderResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.BlockHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::ledger::BlockHeader& _internal_header() const;
  public:
  const ::ledger::BlockHeader& header() const;
  ::ledger::BlockHeader* release_header();
  ::ledger::BlockHeader* mutable_header();
  void set_allocated_header(::ledger::BlockHeader* header);

  // @@protoc_insertion_point(class_scope:ledger.GetBlockHeaderResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::BlockHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetBlockRequest) */ {
 public:
  GetBlockRequest();
  virtual ~GetBlockRequest();

  GetBlockRequest(const GetBlockRequest& from);

  inline GetBlockRequest& operator=(const GetBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockRequest(GetBlockRequest&& from) noexcept
    : GetBlockRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockRequest& operator=(GetBlockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockRequest*>(
               &_GetBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GetBlockRequest* other);
  friend void swap(GetBlockRequest& a, GetBlockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockRequest* New() const final {
    return CreateMaybeMessage<GetBlockRequest>(NULL);
  }

  GetBlockRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlockRequest& from);
  void MergeFrom(const GetBlockRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:ledger.GetBlockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetBlockResponse) */ {
 public:
  GetBlockResponse();
  virtual ~GetBlockResponse();

  GetBlockResponse(const GetBlockResponse& from);

  inline GetBlockResponse& operator=(const GetBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockResponse(GetBlockResponse&& from) noexcept
    : GetBlockResponse() {
    *this = ::std::move(from);
  }

  inline GetBlockResponse& operator=(GetBlockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockResponse* internal_default_instance() {
    return reinterpret_cast<const GetBlockResponse*>(
               &_GetBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GetBlockResponse* other);
  friend void swap(GetBlockResponse& a, GetBlockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockResponse* New() const final {
    return CreateMaybeMessage<GetBlockResponse>(NULL);
  }

  GetBlockResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlockResponse& from);
  void MergeFrom(const GetBlockResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.Block block = 1;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 1;
  private:
  const ::ledger::Block& _internal_block() const;
  public:
  const ::ledger::Block& block() const;
  ::ledger::Block* release_block();
  ::ledger::Block* mutable_block();
  void set_allocated_block(::ledger::Block* block);

  // @@protoc_insertion_point(class_scope:ledger.GetBlockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::Block* block_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlockInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetBlockInfoRequest) */ {
 public:
  GetBlockInfoRequest();
  virtual ~GetBlockInfoRequest();

  GetBlockInfoRequest(const GetBlockInfoRequest& from);

  inline GetBlockInfoRequest& operator=(const GetBlockInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockInfoRequest(GetBlockInfoRequest&& from) noexcept
    : GetBlockInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockInfoRequest& operator=(GetBlockInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockInfoRequest*>(
               &_GetBlockInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(GetBlockInfoRequest* other);
  friend void swap(GetBlockInfoRequest& a, GetBlockInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockInfoRequest* New() const final {
    return CreateMaybeMessage<GetBlockInfoRequest>(NULL);
  }

  GetBlockInfoRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockInfoRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlockInfoRequest& from);
  void MergeFrom(const GetBlockInfoRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:ledger.GetBlockInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBlockInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.GetBlockInfoResponse) */ {
 public:
  GetBlockInfoResponse();
  virtual ~GetBlockInfoResponse();

  GetBlockInfoResponse(const GetBlockInfoResponse& from);

  inline GetBlockInfoResponse& operator=(const GetBlockInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockInfoResponse(GetBlockInfoResponse&& from) noexcept
    : GetBlockInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetBlockInfoResponse& operator=(GetBlockInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetBlockInfoResponse*>(
               &_GetBlockInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(GetBlockInfoResponse* other);
  friend void swap(GetBlockInfoResponse& a, GetBlockInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockInfoResponse* New() const final {
    return CreateMaybeMessage<GetBlockInfoResponse>(NULL);
  }

  GetBlockInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBlockInfoResponse& from);
  void MergeFrom(const GetBlockInfoResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.BlockInfo block_info = 1;
  bool has_block_info() const;
  void clear_block_info();
  static const int kBlockInfoFieldNumber = 1;
  private:
  const ::ledger::BlockInfo& _internal_block_info() const;
  public:
  const ::ledger::BlockInfo& block_info() const;
  ::ledger::BlockInfo* release_block_info();
  ::ledger::BlockInfo* mutable_block_info();
  void set_allocated_block_info(::ledger::BlockInfo* block_info);

  // @@protoc_insertion_point(class_scope:ledger.GetBlockInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::BlockInfo* block_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fledger_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ChainInfo

// string chain_name = 1;
inline void ChainInfo::clear_chain_name() {
  chain_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainInfo::chain_name() const {
  // @@protoc_insertion_point(field_get:ledger.ChainInfo.chain_name)
  return chain_name_.GetNoArena();
}
inline void ChainInfo::set_chain_name(const ::std::string& value) {
  
  chain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.ChainInfo.chain_name)
}
#if LANG_CXX11
inline void ChainInfo::set_chain_name(::std::string&& value) {
  
  chain_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.ChainInfo.chain_name)
}
#endif
inline void ChainInfo::set_chain_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.ChainInfo.chain_name)
}
inline void ChainInfo::set_chain_name(const char* value, size_t size) {
  
  chain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.ChainInfo.chain_name)
}
inline ::std::string* ChainInfo::mutable_chain_name() {
  
  // @@protoc_insertion_point(field_mutable:ledger.ChainInfo.chain_name)
  return chain_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainInfo::release_chain_name() {
  // @@protoc_insertion_point(field_release:ledger.ChainInfo.chain_name)
  
  return chain_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainInfo::set_allocated_chain_name(::std::string* chain_name) {
  if (chain_name != NULL) {
    
  } else {
    
  }
  chain_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chain_name);
  // @@protoc_insertion_point(field_set_allocated:ledger.ChainInfo.chain_name)
}

// uint64 num_blocks = 2;
inline void ChainInfo::clear_num_blocks() {
  num_blocks_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ChainInfo::num_blocks() const {
  // @@protoc_insertion_point(field_get:ledger.ChainInfo.num_blocks)
  return num_blocks_;
}
inline void ChainInfo::set_num_blocks(::google::protobuf::uint64 value) {
  
  num_blocks_ = value;
  // @@protoc_insertion_point(field_set:ledger.ChainInfo.num_blocks)
}

// uint64 num_headers = 3;
inline void ChainInfo::clear_num_headers() {
  num_headers_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ChainInfo::num_headers() const {
  // @@protoc_insertion_point(field_get:ledger.ChainInfo.num_headers)
  return num_headers_;
}
inline void ChainInfo::set_num_headers(::google::protobuf::uint64 value) {
  
  num_headers_ = value;
  // @@protoc_insertion_point(field_set:ledger.ChainInfo.num_headers)
}

// string block_hash = 4;
inline void ChainInfo::clear_block_hash() {
  block_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainInfo::block_hash() const {
  // @@protoc_insertion_point(field_get:ledger.ChainInfo.block_hash)
  return block_hash_.GetNoArena();
}
inline void ChainInfo::set_block_hash(const ::std::string& value) {
  
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.ChainInfo.block_hash)
}
#if LANG_CXX11
inline void ChainInfo::set_block_hash(::std::string&& value) {
  
  block_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.ChainInfo.block_hash)
}
#endif
inline void ChainInfo::set_block_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.ChainInfo.block_hash)
}
inline void ChainInfo::set_block_hash(const char* value, size_t size) {
  
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.ChainInfo.block_hash)
}
inline ::std::string* ChainInfo::mutable_block_hash() {
  
  // @@protoc_insertion_point(field_mutable:ledger.ChainInfo.block_hash)
  return block_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainInfo::release_block_hash() {
  // @@protoc_insertion_point(field_release:ledger.ChainInfo.block_hash)
  
  return block_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainInfo::set_allocated_block_hash(::std::string* block_hash) {
  if (block_hash != NULL) {
    
  } else {
    
  }
  block_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), block_hash);
  // @@protoc_insertion_point(field_set_allocated:ledger.ChainInfo.block_hash)
}

// string difficulty = 5;
inline void ChainInfo::clear_difficulty() {
  difficulty_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainInfo::difficulty() const {
  // @@protoc_insertion_point(field_get:ledger.ChainInfo.difficulty)
  return difficulty_.GetNoArena();
}
inline void ChainInfo::set_difficulty(const ::std::string& value) {
  
  difficulty_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.ChainInfo.difficulty)
}
#if LANG_CXX11
inline void ChainInfo::set_difficulty(::std::string&& value) {
  
  difficulty_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.ChainInfo.difficulty)
}
#endif
inline void ChainInfo::set_difficulty(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  difficulty_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.ChainInfo.difficulty)
}
inline void ChainInfo::set_difficulty(const char* value, size_t size) {
  
  difficulty_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.ChainInfo.difficulty)
}
inline ::std::string* ChainInfo::mutable_difficulty() {
  
  // @@protoc_insertion_point(field_mutable:ledger.ChainInfo.difficulty)
  return difficulty_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainInfo::release_difficulty() {
  // @@protoc_insertion_point(field_release:ledger.ChainInfo.difficulty)
  
  return difficulty_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainInfo::set_allocated_difficulty(::std::string* difficulty) {
  if (difficulty != NULL) {
    
  } else {
    
  }
  difficulty_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), difficulty);
  // @@protoc_insertion_point(field_set_allocated:ledger.ChainInfo.difficulty)
}

// string version = 6;
inline void ChainInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainInfo::version() const {
  // @@protoc_insertion_point(field_get:ledger.ChainInfo.version)
  return version_.GetNoArena();
}
inline void ChainInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.ChainInfo.version)
}
#if LANG_CXX11
inline void ChainInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.ChainInfo.version)
}
#endif
inline void ChainInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.ChainInfo.version)
}
inline void ChainInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.ChainInfo.version)
}
inline ::std::string* ChainInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:ledger.ChainInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainInfo::release_version() {
  // @@protoc_insertion_point(field_release:ledger.ChainInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:ledger.ChainInfo.version)
}

// string sub_version = 7;
inline void ChainInfo::clear_sub_version() {
  sub_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainInfo::sub_version() const {
  // @@protoc_insertion_point(field_get:ledger.ChainInfo.sub_version)
  return sub_version_.GetNoArena();
}
inline void ChainInfo::set_sub_version(const ::std::string& value) {
  
  sub_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.ChainInfo.sub_version)
}
#if LANG_CXX11
inline void ChainInfo::set_sub_version(::std::string&& value) {
  
  sub_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.ChainInfo.sub_version)
}
#endif
inline void ChainInfo::set_sub_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sub_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.ChainInfo.sub_version)
}
inline void ChainInfo::set_sub_version(const char* value, size_t size) {
  
  sub_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.ChainInfo.sub_version)
}
inline ::std::string* ChainInfo::mutable_sub_version() {
  
  // @@protoc_insertion_point(field_mutable:ledger.ChainInfo.sub_version)
  return sub_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainInfo::release_sub_version() {
  // @@protoc_insertion_point(field_release:ledger.ChainInfo.sub_version)
  
  return sub_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainInfo::set_allocated_sub_version(::std::string* sub_version) {
  if (sub_version != NULL) {
    
  } else {
    
  }
  sub_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sub_version);
  // @@protoc_insertion_point(field_set_allocated:ledger.ChainInfo.sub_version)
}

// string protocol_version = 8;
inline void ChainInfo::clear_protocol_version() {
  protocol_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainInfo::protocol_version() const {
  // @@protoc_insertion_point(field_get:ledger.ChainInfo.protocol_version)
  return protocol_version_.GetNoArena();
}
inline void ChainInfo::set_protocol_version(const ::std::string& value) {
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.ChainInfo.protocol_version)
}
#if LANG_CXX11
inline void ChainInfo::set_protocol_version(::std::string&& value) {
  
  protocol_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.ChainInfo.protocol_version)
}
#endif
inline void ChainInfo::set_protocol_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.ChainInfo.protocol_version)
}
inline void ChainInfo::set_protocol_version(const char* value, size_t size) {
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.ChainInfo.protocol_version)
}
inline ::std::string* ChainInfo::mutable_protocol_version() {
  
  // @@protoc_insertion_point(field_mutable:ledger.ChainInfo.protocol_version)
  return protocol_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainInfo::release_protocol_version() {
  // @@protoc_insertion_point(field_release:ledger.ChainInfo.protocol_version)
  
  return protocol_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainInfo::set_allocated_protocol_version(::std::string* protocol_version) {
  if (protocol_version != NULL) {
    
  } else {
    
  }
  protocol_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_version);
  // @@protoc_insertion_point(field_set_allocated:ledger.ChainInfo.protocol_version)
}

// int32 decimals = 9;
inline void ChainInfo::clear_decimals() {
  decimals_ = 0;
}
inline ::google::protobuf::int32 ChainInfo::decimals() const {
  // @@protoc_insertion_point(field_get:ledger.ChainInfo.decimals)
  return decimals_;
}
inline void ChainInfo::set_decimals(::google::protobuf::int32 value) {
  
  decimals_ = value;
  // @@protoc_insertion_point(field_set:ledger.ChainInfo.decimals)
}

// -------------------------------------------------------------------

// BlockHeader

// string hash = 1;
inline void BlockHeader::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader::hash() const {
  // @@protoc_insertion_point(field_get:ledger.BlockHeader.hash)
  return hash_.GetNoArena();
}
inline void BlockHeader::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.BlockHeader.hash)
}
#if LANG_CXX11
inline void BlockHeader::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.BlockHeader.hash)
}
#endif
inline void BlockHeader::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.BlockHeader.hash)
}
inline void BlockHeader::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.BlockHeader.hash)
}
inline ::std::string* BlockHeader::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:ledger.BlockHeader.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader::release_hash() {
  // @@protoc_insertion_point(field_release:ledger.BlockHeader.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:ledger.BlockHeader.hash)
}

// uint64 height = 5;
inline void BlockHeader::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::height() const {
  // @@protoc_insertion_point(field_get:ledger.BlockHeader.height)
  return height_;
}
inline void BlockHeader::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:ledger.BlockHeader.height)
}

// uint64 confirmations = 6;
inline void BlockHeader::clear_confirmations() {
  confirmations_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::confirmations() const {
  // @@protoc_insertion_point(field_get:ledger.BlockHeader.confirmations)
  return confirmations_;
}
inline void BlockHeader::set_confirmations(::google::protobuf::uint64 value) {
  
  confirmations_ = value;
  // @@protoc_insertion_point(field_set:ledger.BlockHeader.confirmations)
}

// uint64 size = 7;
inline void BlockHeader::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::size() const {
  // @@protoc_insertion_point(field_get:ledger.BlockHeader.size)
  return size_;
}
inline void BlockHeader::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:ledger.BlockHeader.size)
}

// .google.protobuf.Timestamp time_stamp = 8;
inline bool BlockHeader::has_time_stamp() const {
  return this != internal_default_instance() && time_stamp_ != NULL;
}
inline const ::google::protobuf::Timestamp& BlockHeader::_internal_time_stamp() const {
  return *time_stamp_;
}
inline const ::google::protobuf::Timestamp& BlockHeader::time_stamp() const {
  const ::google::protobuf::Timestamp* p = time_stamp_;
  // @@protoc_insertion_point(field_get:ledger.BlockHeader.time_stamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* BlockHeader::release_time_stamp() {
  // @@protoc_insertion_point(field_release:ledger.BlockHeader.time_stamp)
  
  ::google::protobuf::Timestamp* temp = time_stamp_;
  time_stamp_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* BlockHeader::mutable_time_stamp() {
  
  if (time_stamp_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    time_stamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.BlockHeader.time_stamp)
  return time_stamp_;
}
inline void BlockHeader::set_allocated_time_stamp(::google::protobuf::Timestamp* time_stamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_stamp_);
  }
  if (time_stamp) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(time_stamp)->GetArena();
    if (message_arena != submessage_arena) {
      time_stamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_stamp, submessage_arena);
    }
    
  } else {
    
  }
  time_stamp_ = time_stamp;
  // @@protoc_insertion_point(field_set_allocated:ledger.BlockHeader.time_stamp)
}

// -------------------------------------------------------------------

// Transaction

// string from = 1;
inline void Transaction::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::from() const {
  // @@protoc_insertion_point(field_get:ledger.Transaction.from)
  return from_.GetNoArena();
}
inline void Transaction::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.Transaction.from)
}
#if LANG_CXX11
inline void Transaction::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.Transaction.from)
}
#endif
inline void Transaction::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.Transaction.from)
}
inline void Transaction::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.Transaction.from)
}
inline ::std::string* Transaction::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:ledger.Transaction.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_from() {
  // @@protoc_insertion_point(field_release:ledger.Transaction.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:ledger.Transaction.from)
}

// string to = 2;
inline void Transaction::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::to() const {
  // @@protoc_insertion_point(field_get:ledger.Transaction.to)
  return to_.GetNoArena();
}
inline void Transaction::set_to(const ::std::string& value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.Transaction.to)
}
#if LANG_CXX11
inline void Transaction::set_to(::std::string&& value) {
  
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.Transaction.to)
}
#endif
inline void Transaction::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.Transaction.to)
}
inline void Transaction::set_to(const char* value, size_t size) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.Transaction.to)
}
inline ::std::string* Transaction::mutable_to() {
  
  // @@protoc_insertion_point(field_mutable:ledger.Transaction.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_to() {
  // @@protoc_insertion_point(field_release:ledger.Transaction.to)
  
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    
  } else {
    
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:ledger.Transaction.to)
}

// string amount = 3;
inline void Transaction::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::amount() const {
  // @@protoc_insertion_point(field_get:ledger.Transaction.amount)
  return amount_.GetNoArena();
}
inline void Transaction::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.Transaction.amount)
}
#if LANG_CXX11
inline void Transaction::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.Transaction.amount)
}
#endif
inline void Transaction::set_amount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.Transaction.amount)
}
inline void Transaction::set_amount(const char* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.Transaction.amount)
}
inline ::std::string* Transaction::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:ledger.Transaction.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_amount() {
  // @@protoc_insertion_point(field_release:ledger.Transaction.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_amount(::std::string* amount) {
  if (amount != NULL) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:ledger.Transaction.amount)
}

// uint64 nonce = 4;
inline void Transaction::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Transaction::nonce() const {
  // @@protoc_insertion_point(field_get:ledger.Transaction.nonce)
  return nonce_;
}
inline void Transaction::set_nonce(::google::protobuf::uint64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:ledger.Transaction.nonce)
}

// .google.protobuf.Timestamp time_stamp = 5;
inline bool Transaction::has_time_stamp() const {
  return this != internal_default_instance() && time_stamp_ != NULL;
}
inline const ::google::protobuf::Timestamp& Transaction::_internal_time_stamp() const {
  return *time_stamp_;
}
inline const ::google::protobuf::Timestamp& Transaction::time_stamp() const {
  const ::google::protobuf::Timestamp* p = time_stamp_;
  // @@protoc_insertion_point(field_get:ledger.Transaction.time_stamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Transaction::release_time_stamp() {
  // @@protoc_insertion_point(field_release:ledger.Transaction.time_stamp)
  
  ::google::protobuf::Timestamp* temp = time_stamp_;
  time_stamp_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Transaction::mutable_time_stamp() {
  
  if (time_stamp_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    time_stamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.Transaction.time_stamp)
  return time_stamp_;
}
inline void Transaction::set_allocated_time_stamp(::google::protobuf::Timestamp* time_stamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_stamp_);
  }
  if (time_stamp) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(time_stamp)->GetArena();
    if (message_arena != submessage_arena) {
      time_stamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_stamp, submessage_arena);
    }
    
  } else {
    
  }
  time_stamp_ = time_stamp;
  // @@protoc_insertion_point(field_set_allocated:ledger.Transaction.time_stamp)
}

// -------------------------------------------------------------------

// Block

// .ledger.BlockHeader header = 1;
inline bool Block::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Block::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::ledger::BlockHeader& Block::_internal_header() const {
  return *header_;
}
inline const ::ledger::BlockHeader& Block::header() const {
  const ::ledger::BlockHeader* p = header_;
  // @@protoc_insertion_point(field_get:ledger.Block.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ledger::BlockHeader*>(
      &::ledger::_BlockHeader_default_instance_);
}
inline ::ledger::BlockHeader* Block::release_header() {
  // @@protoc_insertion_point(field_release:ledger.Block.header)
  
  ::ledger::BlockHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ledger::BlockHeader* Block::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::ledger::BlockHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.Block.header)
  return header_;
}
inline void Block::set_allocated_header(::ledger::BlockHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ledger.Block.header)
}

// string pivot = 2;
inline void Block::clear_pivot() {
  pivot_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::pivot() const {
  // @@protoc_insertion_point(field_get:ledger.Block.pivot)
  return pivot_.GetNoArena();
}
inline void Block::set_pivot(const ::std::string& value) {
  
  pivot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.Block.pivot)
}
#if LANG_CXX11
inline void Block::set_pivot(::std::string&& value) {
  
  pivot_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.Block.pivot)
}
#endif
inline void Block::set_pivot(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pivot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.Block.pivot)
}
inline void Block::set_pivot(const char* value, size_t size) {
  
  pivot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.Block.pivot)
}
inline ::std::string* Block::mutable_pivot() {
  
  // @@protoc_insertion_point(field_mutable:ledger.Block.pivot)
  return pivot_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_pivot() {
  // @@protoc_insertion_point(field_release:ledger.Block.pivot)
  
  return pivot_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_pivot(::std::string* pivot) {
  if (pivot != NULL) {
    
  } else {
    
  }
  pivot_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pivot);
  // @@protoc_insertion_point(field_set_allocated:ledger.Block.pivot)
}

// repeated string past = 3;
inline int Block::past_size() const {
  return past_.size();
}
inline void Block::clear_past() {
  past_.Clear();
}
inline const ::std::string& Block::past(int index) const {
  // @@protoc_insertion_point(field_get:ledger.Block.past)
  return past_.Get(index);
}
inline ::std::string* Block::mutable_past(int index) {
  // @@protoc_insertion_point(field_mutable:ledger.Block.past)
  return past_.Mutable(index);
}
inline void Block::set_past(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ledger.Block.past)
  past_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Block::set_past(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ledger.Block.past)
  past_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Block::set_past(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  past_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ledger.Block.past)
}
inline void Block::set_past(int index, const char* value, size_t size) {
  past_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ledger.Block.past)
}
inline ::std::string* Block::add_past() {
  // @@protoc_insertion_point(field_add_mutable:ledger.Block.past)
  return past_.Add();
}
inline void Block::add_past(const ::std::string& value) {
  past_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ledger.Block.past)
}
#if LANG_CXX11
inline void Block::add_past(::std::string&& value) {
  past_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ledger.Block.past)
}
#endif
inline void Block::add_past(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  past_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ledger.Block.past)
}
inline void Block::add_past(const char* value, size_t size) {
  past_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ledger.Block.past)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::past() const {
  // @@protoc_insertion_point(field_list:ledger.Block.past)
  return past_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_past() {
  // @@protoc_insertion_point(field_mutable_list:ledger.Block.past)
  return &past_;
}

// repeated string future = 4;
inline int Block::future_size() const {
  return future_.size();
}
inline void Block::clear_future() {
  future_.Clear();
}
inline const ::std::string& Block::future(int index) const {
  // @@protoc_insertion_point(field_get:ledger.Block.future)
  return future_.Get(index);
}
inline ::std::string* Block::mutable_future(int index) {
  // @@protoc_insertion_point(field_mutable:ledger.Block.future)
  return future_.Mutable(index);
}
inline void Block::set_future(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ledger.Block.future)
  future_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Block::set_future(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ledger.Block.future)
  future_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Block::set_future(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  future_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ledger.Block.future)
}
inline void Block::set_future(int index, const char* value, size_t size) {
  future_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ledger.Block.future)
}
inline ::std::string* Block::add_future() {
  // @@protoc_insertion_point(field_add_mutable:ledger.Block.future)
  return future_.Add();
}
inline void Block::add_future(const ::std::string& value) {
  future_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ledger.Block.future)
}
#if LANG_CXX11
inline void Block::add_future(::std::string&& value) {
  future_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ledger.Block.future)
}
#endif
inline void Block::add_future(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  future_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ledger.Block.future)
}
inline void Block::add_future(const char* value, size_t size) {
  future_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ledger.Block.future)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::future() const {
  // @@protoc_insertion_point(field_list:ledger.Block.future)
  return future_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_future() {
  // @@protoc_insertion_point(field_mutable_list:ledger.Block.future)
  return &future_;
}

// repeated string anticone = 5;
inline int Block::anticone_size() const {
  return anticone_.size();
}
inline void Block::clear_anticone() {
  anticone_.Clear();
}
inline const ::std::string& Block::anticone(int index) const {
  // @@protoc_insertion_point(field_get:ledger.Block.anticone)
  return anticone_.Get(index);
}
inline ::std::string* Block::mutable_anticone(int index) {
  // @@protoc_insertion_point(field_mutable:ledger.Block.anticone)
  return anticone_.Mutable(index);
}
inline void Block::set_anticone(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ledger.Block.anticone)
  anticone_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Block::set_anticone(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ledger.Block.anticone)
  anticone_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Block::set_anticone(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  anticone_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ledger.Block.anticone)
}
inline void Block::set_anticone(int index, const char* value, size_t size) {
  anticone_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ledger.Block.anticone)
}
inline ::std::string* Block::add_anticone() {
  // @@protoc_insertion_point(field_add_mutable:ledger.Block.anticone)
  return anticone_.Add();
}
inline void Block::add_anticone(const ::std::string& value) {
  anticone_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ledger.Block.anticone)
}
#if LANG_CXX11
inline void Block::add_anticone(::std::string&& value) {
  anticone_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ledger.Block.anticone)
}
#endif
inline void Block::add_anticone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  anticone_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ledger.Block.anticone)
}
inline void Block::add_anticone(const char* value, size_t size) {
  anticone_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ledger.Block.anticone)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::anticone() const {
  // @@protoc_insertion_point(field_list:ledger.Block.anticone)
  return anticone_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_anticone() {
  // @@protoc_insertion_point(field_mutable_list:ledger.Block.anticone)
  return &anticone_;
}

// repeated string tips = 6;
inline int Block::tips_size() const {
  return tips_.size();
}
inline void Block::clear_tips() {
  tips_.Clear();
}
inline const ::std::string& Block::tips(int index) const {
  // @@protoc_insertion_point(field_get:ledger.Block.tips)
  return tips_.Get(index);
}
inline ::std::string* Block::mutable_tips(int index) {
  // @@protoc_insertion_point(field_mutable:ledger.Block.tips)
  return tips_.Mutable(index);
}
inline void Block::set_tips(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ledger.Block.tips)
  tips_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Block::set_tips(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ledger.Block.tips)
  tips_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Block::set_tips(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ledger.Block.tips)
}
inline void Block::set_tips(int index, const char* value, size_t size) {
  tips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ledger.Block.tips)
}
inline ::std::string* Block::add_tips() {
  // @@protoc_insertion_point(field_add_mutable:ledger.Block.tips)
  return tips_.Add();
}
inline void Block::add_tips(const ::std::string& value) {
  tips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ledger.Block.tips)
}
#if LANG_CXX11
inline void Block::add_tips(::std::string&& value) {
  tips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ledger.Block.tips)
}
#endif
inline void Block::add_tips(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ledger.Block.tips)
}
inline void Block::add_tips(const char* value, size_t size) {
  tips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ledger.Block.tips)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::tips() const {
  // @@protoc_insertion_point(field_list:ledger.Block.tips)
  return tips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_tips() {
  // @@protoc_insertion_point(field_mutable_list:ledger.Block.tips)
  return &tips_;
}

// repeated .ledger.Transaction transactions = 7;
inline int Block::transactions_size() const {
  return transactions_.size();
}
inline void Block::clear_transactions() {
  transactions_.Clear();
}
inline ::ledger::Transaction* Block::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:ledger.Block.transactions)
  return transactions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ledger::Transaction >*
Block::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:ledger.Block.transactions)
  return &transactions_;
}
inline const ::ledger::Transaction& Block::transactions(int index) const {
  // @@protoc_insertion_point(field_get:ledger.Block.transactions)
  return transactions_.Get(index);
}
inline ::ledger::Transaction* Block::add_transactions() {
  // @@protoc_insertion_point(field_add:ledger.Block.transactions)
  return transactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ledger::Transaction >&
Block::transactions() const {
  // @@protoc_insertion_point(field_list:ledger.Block.transactions)
  return transactions_;
}

// bytes signature = 8;
inline void Block::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::signature() const {
  // @@protoc_insertion_point(field_get:ledger.Block.signature)
  return signature_.GetNoArena();
}
inline void Block::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.Block.signature)
}
#if LANG_CXX11
inline void Block::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.Block.signature)
}
#endif
inline void Block::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.Block.signature)
}
inline void Block::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.Block.signature)
}
inline ::std::string* Block::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:ledger.Block.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_signature() {
  // @@protoc_insertion_point(field_release:ledger.Block.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:ledger.Block.signature)
}

// string hash = 9;
inline void Block::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::hash() const {
  // @@protoc_insertion_point(field_get:ledger.Block.hash)
  return hash_.GetNoArena();
}
inline void Block::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.Block.hash)
}
#if LANG_CXX11
inline void Block::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.Block.hash)
}
#endif
inline void Block::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.Block.hash)
}
inline void Block::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.Block.hash)
}
inline ::std::string* Block::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:ledger.Block.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_hash() {
  // @@protoc_insertion_point(field_release:ledger.Block.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:ledger.Block.hash)
}

// string publisher = 10;
inline void Block::clear_publisher() {
  publisher_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::publisher() const {
  // @@protoc_insertion_point(field_get:ledger.Block.publisher)
  return publisher_.GetNoArena();
}
inline void Block::set_publisher(const ::std::string& value) {
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.Block.publisher)
}
#if LANG_CXX11
inline void Block::set_publisher(::std::string&& value) {
  
  publisher_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.Block.publisher)
}
#endif
inline void Block::set_publisher(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.Block.publisher)
}
inline void Block::set_publisher(const char* value, size_t size) {
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.Block.publisher)
}
inline ::std::string* Block::mutable_publisher() {
  
  // @@protoc_insertion_point(field_mutable:ledger.Block.publisher)
  return publisher_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_publisher() {
  // @@protoc_insertion_point(field_release:ledger.Block.publisher)
  
  return publisher_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_publisher(::std::string* publisher) {
  if (publisher != NULL) {
    
  } else {
    
  }
  publisher_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publisher);
  // @@protoc_insertion_point(field_set_allocated:ledger.Block.publisher)
}

// -------------------------------------------------------------------

// BlockInfo

// .ledger.BlockHeader header = 1;
inline bool BlockInfo::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void BlockInfo::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::ledger::BlockHeader& BlockInfo::_internal_header() const {
  return *header_;
}
inline const ::ledger::BlockHeader& BlockInfo::header() const {
  const ::ledger::BlockHeader* p = header_;
  // @@protoc_insertion_point(field_get:ledger.BlockInfo.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ledger::BlockHeader*>(
      &::ledger::_BlockHeader_default_instance_);
}
inline ::ledger::BlockHeader* BlockInfo::release_header() {
  // @@protoc_insertion_point(field_release:ledger.BlockInfo.header)
  
  ::ledger::BlockHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ledger::BlockHeader* BlockInfo::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::ledger::BlockHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.BlockInfo.header)
  return header_;
}
inline void BlockInfo::set_allocated_header(::ledger::BlockHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ledger.BlockInfo.header)
}

// string merkle_root = 2;
inline void BlockInfo::clear_merkle_root() {
  merkle_root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockInfo::merkle_root() const {
  // @@protoc_insertion_point(field_get:ledger.BlockInfo.merkle_root)
  return merkle_root_.GetNoArena();
}
inline void BlockInfo::set_merkle_root(const ::std::string& value) {
  
  merkle_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.BlockInfo.merkle_root)
}
#if LANG_CXX11
inline void BlockInfo::set_merkle_root(::std::string&& value) {
  
  merkle_root_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.BlockInfo.merkle_root)
}
#endif
inline void BlockInfo::set_merkle_root(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  merkle_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.BlockInfo.merkle_root)
}
inline void BlockInfo::set_merkle_root(const char* value, size_t size) {
  
  merkle_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.BlockInfo.merkle_root)
}
inline ::std::string* BlockInfo::mutable_merkle_root() {
  
  // @@protoc_insertion_point(field_mutable:ledger.BlockInfo.merkle_root)
  return merkle_root_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockInfo::release_merkle_root() {
  // @@protoc_insertion_point(field_release:ledger.BlockInfo.merkle_root)
  
  return merkle_root_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockInfo::set_allocated_merkle_root(::std::string* merkle_root) {
  if (merkle_root != NULL) {
    
  } else {
    
  }
  merkle_root_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), merkle_root);
  // @@protoc_insertion_point(field_set_allocated:ledger.BlockInfo.merkle_root)
}

// string version = 3;
inline void BlockInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockInfo::version() const {
  // @@protoc_insertion_point(field_get:ledger.BlockInfo.version)
  return version_.GetNoArena();
}
inline void BlockInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.BlockInfo.version)
}
#if LANG_CXX11
inline void BlockInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.BlockInfo.version)
}
#endif
inline void BlockInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.BlockInfo.version)
}
inline void BlockInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.BlockInfo.version)
}
inline ::std::string* BlockInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:ledger.BlockInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockInfo::release_version() {
  // @@protoc_insertion_point(field_release:ledger.BlockInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:ledger.BlockInfo.version)
}

// uint64 nonce = 4;
inline void BlockInfo::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockInfo::nonce() const {
  // @@protoc_insertion_point(field_get:ledger.BlockInfo.nonce)
  return nonce_;
}
inline void BlockInfo::set_nonce(::google::protobuf::uint64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:ledger.BlockInfo.nonce)
}

// string difficulty = 5;
inline void BlockInfo::clear_difficulty() {
  difficulty_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockInfo::difficulty() const {
  // @@protoc_insertion_point(field_get:ledger.BlockInfo.difficulty)
  return difficulty_.GetNoArena();
}
inline void BlockInfo::set_difficulty(const ::std::string& value) {
  
  difficulty_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.BlockInfo.difficulty)
}
#if LANG_CXX11
inline void BlockInfo::set_difficulty(::std::string&& value) {
  
  difficulty_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.BlockInfo.difficulty)
}
#endif
inline void BlockInfo::set_difficulty(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  difficulty_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.BlockInfo.difficulty)
}
inline void BlockInfo::set_difficulty(const char* value, size_t size) {
  
  difficulty_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.BlockInfo.difficulty)
}
inline ::std::string* BlockInfo::mutable_difficulty() {
  
  // @@protoc_insertion_point(field_mutable:ledger.BlockInfo.difficulty)
  return difficulty_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockInfo::release_difficulty() {
  // @@protoc_insertion_point(field_release:ledger.BlockInfo.difficulty)
  
  return difficulty_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockInfo::set_allocated_difficulty(::std::string* difficulty) {
  if (difficulty != NULL) {
    
  } else {
    
  }
  difficulty_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), difficulty);
  // @@protoc_insertion_point(field_set_allocated:ledger.BlockInfo.difficulty)
}

// repeated string transaction_ids = 6;
inline int BlockInfo::transaction_ids_size() const {
  return transaction_ids_.size();
}
inline void BlockInfo::clear_transaction_ids() {
  transaction_ids_.Clear();
}
inline const ::std::string& BlockInfo::transaction_ids(int index) const {
  // @@protoc_insertion_point(field_get:ledger.BlockInfo.transaction_ids)
  return transaction_ids_.Get(index);
}
inline ::std::string* BlockInfo::mutable_transaction_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ledger.BlockInfo.transaction_ids)
  return transaction_ids_.Mutable(index);
}
inline void BlockInfo::set_transaction_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ledger.BlockInfo.transaction_ids)
  transaction_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BlockInfo::set_transaction_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ledger.BlockInfo.transaction_ids)
  transaction_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BlockInfo::set_transaction_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  transaction_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ledger.BlockInfo.transaction_ids)
}
inline void BlockInfo::set_transaction_ids(int index, const char* value, size_t size) {
  transaction_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ledger.BlockInfo.transaction_ids)
}
inline ::std::string* BlockInfo::add_transaction_ids() {
  // @@protoc_insertion_point(field_add_mutable:ledger.BlockInfo.transaction_ids)
  return transaction_ids_.Add();
}
inline void BlockInfo::add_transaction_ids(const ::std::string& value) {
  transaction_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ledger.BlockInfo.transaction_ids)
}
#if LANG_CXX11
inline void BlockInfo::add_transaction_ids(::std::string&& value) {
  transaction_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ledger.BlockInfo.transaction_ids)
}
#endif
inline void BlockInfo::add_transaction_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  transaction_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ledger.BlockInfo.transaction_ids)
}
inline void BlockInfo::add_transaction_ids(const char* value, size_t size) {
  transaction_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ledger.BlockInfo.transaction_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BlockInfo::transaction_ids() const {
  // @@protoc_insertion_point(field_list:ledger.BlockInfo.transaction_ids)
  return transaction_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BlockInfo::mutable_transaction_ids() {
  // @@protoc_insertion_point(field_mutable_list:ledger.BlockInfo.transaction_ids)
  return &transaction_ids_;
}

// -------------------------------------------------------------------

// IsTestnetResponse

// bool is_testnet = 1;
inline void IsTestnetResponse::clear_is_testnet() {
  is_testnet_ = false;
}
inline bool IsTestnetResponse::is_testnet() const {
  // @@protoc_insertion_point(field_get:ledger.IsTestnetResponse.is_testnet)
  return is_testnet_;
}
inline void IsTestnetResponse::set_is_testnet(bool value) {
  
  is_testnet_ = value;
  // @@protoc_insertion_point(field_set:ledger.IsTestnetResponse.is_testnet)
}

// -------------------------------------------------------------------

// GetNetworkNameResponse

// string network_name = 1;
inline void GetNetworkNameResponse::clear_network_name() {
  network_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetNetworkNameResponse::network_name() const {
  // @@protoc_insertion_point(field_get:ledger.GetNetworkNameResponse.network_name)
  return network_name_.GetNoArena();
}
inline void GetNetworkNameResponse::set_network_name(const ::std::string& value) {
  
  network_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.GetNetworkNameResponse.network_name)
}
#if LANG_CXX11
inline void GetNetworkNameResponse::set_network_name(::std::string&& value) {
  
  network_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.GetNetworkNameResponse.network_name)
}
#endif
inline void GetNetworkNameResponse::set_network_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  network_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.GetNetworkNameResponse.network_name)
}
inline void GetNetworkNameResponse::set_network_name(const char* value, size_t size) {
  
  network_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.GetNetworkNameResponse.network_name)
}
inline ::std::string* GetNetworkNameResponse::mutable_network_name() {
  
  // @@protoc_insertion_point(field_mutable:ledger.GetNetworkNameResponse.network_name)
  return network_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetNetworkNameResponse::release_network_name() {
  // @@protoc_insertion_point(field_release:ledger.GetNetworkNameResponse.network_name)
  
  return network_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetNetworkNameResponse::set_allocated_network_name(::std::string* network_name) {
  if (network_name != NULL) {
    
  } else {
    
  }
  network_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), network_name);
  // @@protoc_insertion_point(field_set_allocated:ledger.GetNetworkNameResponse.network_name)
}

// -------------------------------------------------------------------

// GetVersionResponse

// string version = 1;
inline void GetVersionResponse::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetVersionResponse::version() const {
  // @@protoc_insertion_point(field_get:ledger.GetVersionResponse.version)
  return version_.GetNoArena();
}
inline void GetVersionResponse::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.GetVersionResponse.version)
}
#if LANG_CXX11
inline void GetVersionResponse::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.GetVersionResponse.version)
}
#endif
inline void GetVersionResponse::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.GetVersionResponse.version)
}
inline void GetVersionResponse::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.GetVersionResponse.version)
}
inline ::std::string* GetVersionResponse::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:ledger.GetVersionResponse.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetVersionResponse::release_version() {
  // @@protoc_insertion_point(field_release:ledger.GetVersionResponse.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetVersionResponse::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:ledger.GetVersionResponse.version)
}

// -------------------------------------------------------------------

// GetSubversionResponse

// string sub_version = 1;
inline void GetSubversionResponse::clear_sub_version() {
  sub_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetSubversionResponse::sub_version() const {
  // @@protoc_insertion_point(field_get:ledger.GetSubversionResponse.sub_version)
  return sub_version_.GetNoArena();
}
inline void GetSubversionResponse::set_sub_version(const ::std::string& value) {
  
  sub_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.GetSubversionResponse.sub_version)
}
#if LANG_CXX11
inline void GetSubversionResponse::set_sub_version(::std::string&& value) {
  
  sub_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.GetSubversionResponse.sub_version)
}
#endif
inline void GetSubversionResponse::set_sub_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sub_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.GetSubversionResponse.sub_version)
}
inline void GetSubversionResponse::set_sub_version(const char* value, size_t size) {
  
  sub_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.GetSubversionResponse.sub_version)
}
inline ::std::string* GetSubversionResponse::mutable_sub_version() {
  
  // @@protoc_insertion_point(field_mutable:ledger.GetSubversionResponse.sub_version)
  return sub_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSubversionResponse::release_sub_version() {
  // @@protoc_insertion_point(field_release:ledger.GetSubversionResponse.sub_version)
  
  return sub_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSubversionResponse::set_allocated_sub_version(::std::string* sub_version) {
  if (sub_version != NULL) {
    
  } else {
    
  }
  sub_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sub_version);
  // @@protoc_insertion_point(field_set_allocated:ledger.GetSubversionResponse.sub_version)
}

// -------------------------------------------------------------------

// GetCoinNameResponse

// string coin_name = 1;
inline void GetCoinNameResponse::clear_coin_name() {
  coin_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetCoinNameResponse::coin_name() const {
  // @@protoc_insertion_point(field_get:ledger.GetCoinNameResponse.coin_name)
  return coin_name_.GetNoArena();
}
inline void GetCoinNameResponse::set_coin_name(const ::std::string& value) {
  
  coin_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.GetCoinNameResponse.coin_name)
}
#if LANG_CXX11
inline void GetCoinNameResponse::set_coin_name(::std::string&& value) {
  
  coin_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.GetCoinNameResponse.coin_name)
}
#endif
inline void GetCoinNameResponse::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  coin_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.GetCoinNameResponse.coin_name)
}
inline void GetCoinNameResponse::set_coin_name(const char* value, size_t size) {
  
  coin_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.GetCoinNameResponse.coin_name)
}
inline ::std::string* GetCoinNameResponse::mutable_coin_name() {
  
  // @@protoc_insertion_point(field_mutable:ledger.GetCoinNameResponse.coin_name)
  return coin_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetCoinNameResponse::release_coin_name() {
  // @@protoc_insertion_point(field_release:ledger.GetCoinNameResponse.coin_name)
  
  return coin_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetCoinNameResponse::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    
  } else {
    
  }
  coin_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:ledger.GetCoinNameResponse.coin_name)
}

// -------------------------------------------------------------------

// GetChainInfoResponse

// .ledger.ChainInfo chain_info = 1;
inline bool GetChainInfoResponse::has_chain_info() const {
  return this != internal_default_instance() && chain_info_ != NULL;
}
inline void GetChainInfoResponse::clear_chain_info() {
  if (GetArenaNoVirtual() == NULL && chain_info_ != NULL) {
    delete chain_info_;
  }
  chain_info_ = NULL;
}
inline const ::ledger::ChainInfo& GetChainInfoResponse::_internal_chain_info() const {
  return *chain_info_;
}
inline const ::ledger::ChainInfo& GetChainInfoResponse::chain_info() const {
  const ::ledger::ChainInfo* p = chain_info_;
  // @@protoc_insertion_point(field_get:ledger.GetChainInfoResponse.chain_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ledger::ChainInfo*>(
      &::ledger::_ChainInfo_default_instance_);
}
inline ::ledger::ChainInfo* GetChainInfoResponse::release_chain_info() {
  // @@protoc_insertion_point(field_release:ledger.GetChainInfoResponse.chain_info)
  
  ::ledger::ChainInfo* temp = chain_info_;
  chain_info_ = NULL;
  return temp;
}
inline ::ledger::ChainInfo* GetChainInfoResponse::mutable_chain_info() {
  
  if (chain_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ledger::ChainInfo>(GetArenaNoVirtual());
    chain_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.GetChainInfoResponse.chain_info)
  return chain_info_;
}
inline void GetChainInfoResponse::set_allocated_chain_info(::ledger::ChainInfo* chain_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete chain_info_;
  }
  if (chain_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chain_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chain_info, submessage_arena);
    }
    
  } else {
    
  }
  chain_info_ = chain_info;
  // @@protoc_insertion_point(field_set_allocated:ledger.GetChainInfoResponse.chain_info)
}

// -------------------------------------------------------------------

// GetBestBlockHashResponse

// string block_hash = 1;
inline void GetBestBlockHashResponse::clear_block_hash() {
  block_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBestBlockHashResponse::block_hash() const {
  // @@protoc_insertion_point(field_get:ledger.GetBestBlockHashResponse.block_hash)
  return block_hash_.GetNoArena();
}
inline void GetBestBlockHashResponse::set_block_hash(const ::std::string& value) {
  
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.GetBestBlockHashResponse.block_hash)
}
#if LANG_CXX11
inline void GetBestBlockHashResponse::set_block_hash(::std::string&& value) {
  
  block_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.GetBestBlockHashResponse.block_hash)
}
#endif
inline void GetBestBlockHashResponse::set_block_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.GetBestBlockHashResponse.block_hash)
}
inline void GetBestBlockHashResponse::set_block_hash(const char* value, size_t size) {
  
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.GetBestBlockHashResponse.block_hash)
}
inline ::std::string* GetBestBlockHashResponse::mutable_block_hash() {
  
  // @@protoc_insertion_point(field_mutable:ledger.GetBestBlockHashResponse.block_hash)
  return block_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBestBlockHashResponse::release_block_hash() {
  // @@protoc_insertion_point(field_release:ledger.GetBestBlockHashResponse.block_hash)
  
  return block_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBestBlockHashResponse::set_allocated_block_hash(::std::string* block_hash) {
  if (block_hash != NULL) {
    
  } else {
    
  }
  block_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), block_hash);
  // @@protoc_insertion_point(field_set_allocated:ledger.GetBestBlockHashResponse.block_hash)
}

// -------------------------------------------------------------------

// GetBestBlockHeightResponse

// uint64 height = 1;
inline void GetBestBlockHeightResponse::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetBestBlockHeightResponse::height() const {
  // @@protoc_insertion_point(field_get:ledger.GetBestBlockHeightResponse.height)
  return height_;
}
inline void GetBestBlockHeightResponse::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:ledger.GetBestBlockHeightResponse.height)
}

// -------------------------------------------------------------------

// GetBlockHashRequest

// uint64 height = 1;
inline void GetBlockHashRequest::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetBlockHashRequest::height() const {
  // @@protoc_insertion_point(field_get:ledger.GetBlockHashRequest.height)
  return height_;
}
inline void GetBlockHashRequest::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:ledger.GetBlockHashRequest.height)
}

// -------------------------------------------------------------------

// GetBlockHashResponse

// string hash = 1;
inline void GetBlockHashResponse::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBlockHashResponse::hash() const {
  // @@protoc_insertion_point(field_get:ledger.GetBlockHashResponse.hash)
  return hash_.GetNoArena();
}
inline void GetBlockHashResponse::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.GetBlockHashResponse.hash)
}
#if LANG_CXX11
inline void GetBlockHashResponse::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.GetBlockHashResponse.hash)
}
#endif
inline void GetBlockHashResponse::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.GetBlockHashResponse.hash)
}
inline void GetBlockHashResponse::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.GetBlockHashResponse.hash)
}
inline ::std::string* GetBlockHashResponse::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:ledger.GetBlockHashResponse.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBlockHashResponse::release_hash() {
  // @@protoc_insertion_point(field_release:ledger.GetBlockHashResponse.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBlockHashResponse::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:ledger.GetBlockHashResponse.hash)
}

// -------------------------------------------------------------------

// GetBlockHeaderRequest

// string hash = 1;
inline void GetBlockHeaderRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBlockHeaderRequest::hash() const {
  // @@protoc_insertion_point(field_get:ledger.GetBlockHeaderRequest.hash)
  return hash_.GetNoArena();
}
inline void GetBlockHeaderRequest::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.GetBlockHeaderRequest.hash)
}
#if LANG_CXX11
inline void GetBlockHeaderRequest::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.GetBlockHeaderRequest.hash)
}
#endif
inline void GetBlockHeaderRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.GetBlockHeaderRequest.hash)
}
inline void GetBlockHeaderRequest::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.GetBlockHeaderRequest.hash)
}
inline ::std::string* GetBlockHeaderRequest::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:ledger.GetBlockHeaderRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBlockHeaderRequest::release_hash() {
  // @@protoc_insertion_point(field_release:ledger.GetBlockHeaderRequest.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBlockHeaderRequest::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:ledger.GetBlockHeaderRequest.hash)
}

// -------------------------------------------------------------------

// GetBlockHeaderResponse

// .ledger.BlockHeader header = 1;
inline bool GetBlockHeaderResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetBlockHeaderResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::ledger::BlockHeader& GetBlockHeaderResponse::_internal_header() const {
  return *header_;
}
inline const ::ledger::BlockHeader& GetBlockHeaderResponse::header() const {
  const ::ledger::BlockHeader* p = header_;
  // @@protoc_insertion_point(field_get:ledger.GetBlockHeaderResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ledger::BlockHeader*>(
      &::ledger::_BlockHeader_default_instance_);
}
inline ::ledger::BlockHeader* GetBlockHeaderResponse::release_header() {
  // @@protoc_insertion_point(field_release:ledger.GetBlockHeaderResponse.header)
  
  ::ledger::BlockHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ledger::BlockHeader* GetBlockHeaderResponse::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::ledger::BlockHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.GetBlockHeaderResponse.header)
  return header_;
}
inline void GetBlockHeaderResponse::set_allocated_header(::ledger::BlockHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:ledger.GetBlockHeaderResponse.header)
}

// -------------------------------------------------------------------

// GetBlockRequest

// string hash = 1;
inline void GetBlockRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBlockRequest::hash() const {
  // @@protoc_insertion_point(field_get:ledger.GetBlockRequest.hash)
  return hash_.GetNoArena();
}
inline void GetBlockRequest::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.GetBlockRequest.hash)
}
#if LANG_CXX11
inline void GetBlockRequest::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.GetBlockRequest.hash)
}
#endif
inline void GetBlockRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.GetBlockRequest.hash)
}
inline void GetBlockRequest::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.GetBlockRequest.hash)
}
inline ::std::string* GetBlockRequest::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:ledger.GetBlockRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBlockRequest::release_hash() {
  // @@protoc_insertion_point(field_release:ledger.GetBlockRequest.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBlockRequest::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:ledger.GetBlockRequest.hash)
}

// -------------------------------------------------------------------

// GetBlockResponse

// .ledger.Block block = 1;
inline bool GetBlockResponse::has_block() const {
  return this != internal_default_instance() && block_ != NULL;
}
inline void GetBlockResponse::clear_block() {
  if (GetArenaNoVirtual() == NULL && block_ != NULL) {
    delete block_;
  }
  block_ = NULL;
}
inline const ::ledger::Block& GetBlockResponse::_internal_block() const {
  return *block_;
}
inline const ::ledger::Block& GetBlockResponse::block() const {
  const ::ledger::Block* p = block_;
  // @@protoc_insertion_point(field_get:ledger.GetBlockResponse.block)
  return p != NULL ? *p : *reinterpret_cast<const ::ledger::Block*>(
      &::ledger::_Block_default_instance_);
}
inline ::ledger::Block* GetBlockResponse::release_block() {
  // @@protoc_insertion_point(field_release:ledger.GetBlockResponse.block)
  
  ::ledger::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline ::ledger::Block* GetBlockResponse::mutable_block() {
  
  if (block_ == NULL) {
    auto* p = CreateMaybeMessage<::ledger::Block>(GetArenaNoVirtual());
    block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.GetBlockResponse.block)
  return block_;
}
inline void GetBlockResponse::set_allocated_block(::ledger::Block* block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete block_;
  }
  if (block) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:ledger.GetBlockResponse.block)
}

// -------------------------------------------------------------------

// GetBlockInfoRequest

// string hash = 1;
inline void GetBlockInfoRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBlockInfoRequest::hash() const {
  // @@protoc_insertion_point(field_get:ledger.GetBlockInfoRequest.hash)
  return hash_.GetNoArena();
}
inline void GetBlockInfoRequest::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.GetBlockInfoRequest.hash)
}
#if LANG_CXX11
inline void GetBlockInfoRequest::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.GetBlockInfoRequest.hash)
}
#endif
inline void GetBlockInfoRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.GetBlockInfoRequest.hash)
}
inline void GetBlockInfoRequest::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.GetBlockInfoRequest.hash)
}
inline ::std::string* GetBlockInfoRequest::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:ledger.GetBlockInfoRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBlockInfoRequest::release_hash() {
  // @@protoc_insertion_point(field_release:ledger.GetBlockInfoRequest.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBlockInfoRequest::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:ledger.GetBlockInfoRequest.hash)
}

// -------------------------------------------------------------------

// GetBlockInfoResponse

// .ledger.BlockInfo block_info = 1;
inline bool GetBlockInfoResponse::has_block_info() const {
  return this != internal_default_instance() && block_info_ != NULL;
}
inline void GetBlockInfoResponse::clear_block_info() {
  if (GetArenaNoVirtual() == NULL && block_info_ != NULL) {
    delete block_info_;
  }
  block_info_ = NULL;
}
inline const ::ledger::BlockInfo& GetBlockInfoResponse::_internal_block_info() const {
  return *block_info_;
}
inline const ::ledger::BlockInfo& GetBlockInfoResponse::block_info() const {
  const ::ledger::BlockInfo* p = block_info_;
  // @@protoc_insertion_point(field_get:ledger.GetBlockInfoResponse.block_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ledger::BlockInfo*>(
      &::ledger::_BlockInfo_default_instance_);
}
inline ::ledger::BlockInfo* GetBlockInfoResponse::release_block_info() {
  // @@protoc_insertion_point(field_release:ledger.GetBlockInfoResponse.block_info)
  
  ::ledger::BlockInfo* temp = block_info_;
  block_info_ = NULL;
  return temp;
}
inline ::ledger::BlockInfo* GetBlockInfoResponse::mutable_block_info() {
  
  if (block_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ledger::BlockInfo>(GetArenaNoVirtual());
    block_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.GetBlockInfoResponse.block_info)
  return block_info_;
}
inline void GetBlockInfoResponse::set_allocated_block_info(::ledger::BlockInfo* block_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete block_info_;
  }
  if (block_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      block_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block_info, submessage_arena);
    }
    
  } else {
    
  }
  block_info_ = block_info;
  // @@protoc_insertion_point(field_set_allocated:ledger.GetBlockInfoResponse.block_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ledger

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_proto_2fledger_2eproto
